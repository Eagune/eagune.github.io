{"meta":{"title":"Eagune's Blog","subtitle":"","description":"","author":"Eagune","url":"https://eagune.github.io","root":"/"},"pages":[{"title":"","date":"2020-05-18T13:36:13.625Z","updated":"2020-05-18T13:36:13.625Z","comments":true,"path":"index.html","permalink":"https://eagune.github.io/index.html","excerpt":"","text":""}],"posts":[{"title":"（八）指令解析","slug":"vue深入理解/指令解析","date":"2020-05-16T20:42:31.000Z","updated":"2020-05-18T13:36:13.573Z","comments":true,"path":"vue深入理解/指令解析/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90/","excerpt":"指令解析指令的解析和之前的文本解析差不多，我们都需要遍历节点最后执行compileNode进行解析，这里我们加一个判断如果节点是元素我们就进入我们的指令解析compileDirectives。","text":"指令解析指令的解析和之前的文本解析差不多，我们都需要遍历节点最后执行compileNode进行解析，这里我们加一个判断如果节点是元素我们就进入我们的指令解析compileDirectives。 123456789101112131415161718192021222324252627function compileNode (node) &#123; var type = node.nodeType if (type === 1) &#123; return compileElement(node) &#125; else if (type === 3 &amp;&amp; node.data.trim()) &#123; compileTextNode(node) &#125;&#125;function compileElement (el) &#123; var linkFn var hasAttrs = el.hasAttributes() var attrs = hasAttrs &amp;&amp; toArray(el.attributes) compileDirectives(el, attrs)&#125;function compileDirectives (el, attrs) &#123; var i = attrs.length var dirs = [] var attr, name, rawName, rawValue, value, dirName, arg, dirDef, matched while (i--) &#123; attr = attrs[i] name = rawName = attr.name value = rawValue = attr.value // 各种指令处理 &#125;&#125; 以上是一个大的结构，省略了指令的具体处理，后面我们对指令一个一个去分析。 v-on指令1234567891011121314151617181920212223242526272829303132333435363738var onRE = /^v-on:|^@/function compileDirectives (attrs) &#123; ... if (onRE.test(name)) &#123; arg = name.replace(onRE, '') var descriptor = &#123; name: 'on', attr: rawName, raw: rawValue, def: publicDirectives.on, arg: arg, expression: value &#125; new Directive(descriptor, el) &#125; ...&#125;function on (el, event, cb, useCapture) &#123; el.addEventListener(event, cb, useCapture)&#125;var publicDirectives = &#123; on: &#123; update (handler) &#123; if (!this.descriptor.raw) &#123; handler = function () &#123;&#125; &#125; var vm = this.vm this.handler = function (e) &#123; return handler.call(vm, e) &#125; on(this.el, this.arg, this.handler) &#125;, &#125;&#125; 查看DEMO v-bind指令我们对不同bind指令区分做处理： 将style和class指令和一般的bind指令区分开处理 对于value|checked|selected等属性我们不仅需要修改属性的值同时我们还需要修改元素上对应的值 对于draggable|contenteditable|spellcheck这种枚举型的值我们只允许true和false 其实v-bind指令还支持对象的形式，只是用的比较少这里也省略了。 123456789101112131415161718192021222324var bindRE = /^v-bind:|^:/function compileDirectives (attrs) &#123; ... if (bindRE.test(name)) &#123; dirName = name.replace(bindRE, '') var descriptor = &#123; name: 'bind', attr: rawName, raw: rawValue, arg: arg, expression: value &#125; if (dirName === 'style' || dirName === 'class') &#123; descriptor.def = internalDirectives[dirName] new Directive(descriptor, el) &#125; else &#123; arg = dirName descriptor.def = publicDirectives.bind new Directive(descriptor, el) &#125; &#125; ...&#125; 对于一般的指令123456789101112131415161718192021222324252627282930313233343536var attrWithPropsRE = /^(?:value|checked|selected|muted)$/var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/var publicDirectives = &#123; bind: &#123; update (value) &#123; var attr = this.arg if (this.arg) &#123; this.handleSingle(attr, value) &#125; &#125;, handleSingle (attr, value) &#123; var el = this.el if (attrWithPropsRE.test(attr) &amp;&amp; attr in el) &#123; var attrValue = attr === 'value' ? value == null ? '' : value//IE9 will set input.value to \"null\" for null... : value if (el[attr] !== attrValue) &#123; el[attr] = attrValue &#125; &#125; // do not set value attribute for textarea if (attr === 'value' &amp;&amp; el.tagName === 'TEXTAREA') &#123; el.removeAttribute(attr) return &#125; // update attribute if (enumeratedAttrRE.test(attr)) &#123; el.setAttribute(attr, value ? 'true' : 'false') &#125; else if (value != null &amp;&amp; value !== false) &#123; el.setAttribute(attr, value === true ? '' : value) &#125; else &#123; el.removeAttribute(attr) &#125; &#125; &#125;&#125; 对于style指令12345678910111213141516171819202122232425262728293031323334353637383940414243var publicDirectives = &#123; style: &#123; update (value) &#123; if (typeof value === 'string') &#123; this.el.style.cssText = value &#125; else if (Array.isArray(value)) &#123; this.handleObject(value.reduce(extend, &#123;&#125;)) &#125; else &#123; this.handleObject(value || &#123;&#125;) &#125; &#125;, handleObject (value) &#123; // cache object styles so that only changed props // are actually updated. var cache = this.cache || (this.cache = &#123;&#125;) var name, val for (name in cache) &#123; if (!(name in value)) &#123; this.handleSingle(name, null) delete cache[name] &#125; &#125; for (name in value) &#123; val = value[name] if (val !== cache[name]) &#123; cache[name] = val this.handleSingle(name, val) &#125; &#125; &#125;, handleSingle (prop, value) &#123; prop = normalize(prop) if (!prop) return // unsupported prop // cast possible numbers/booleans into strings if (value != null) value += '' if (value) &#123; this.el.style[prop.camel] = value &#125; else &#123; this.el.style[prop.camel] = '' &#125; &#125; &#125;&#125; 对于class指令12345678910111213141516171819202122232425262728293031323334var publicDirectives = &#123; class: &#123; update (value) &#123; if (!value) &#123; this.cleanup() &#125; else if (typeof value === 'string') &#123; this.setClass(value.trim().split(/\\s+/)) &#125; else &#123; this.setClass(normalize(value)) &#125; &#125;, setClass (value) &#123; this.cleanup(value) for (var i = 0, l = value.length; i &lt; l; i++) &#123; var val = value[i] if (val) &#123; apply(this.el, val, addClass) &#125; &#125; this.prevKeys = value &#125;, cleanup (value) &#123; const prevKeys = this.prevKeys if (!prevKeys) return var i = prevKeys.length while (i--) &#123; var key = prevKeys[i] if (!value || value.indexOf(key) &lt; 0) &#123; apply(this.el, key, removeClass) &#125; &#125; &#125; &#125;&#125; Demo查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"指令","slug":"指令","permalink":"https://eagune.github.io/tags/%E6%8C%87%E4%BB%A4/"},{"name":"解析","slug":"解析","permalink":"https://eagune.github.io/tags/%E8%A7%A3%E6%9E%90/"}]},{"title":"（七）Directives行为预设","slug":"vue深入理解/Directives行为预设","date":"2020-05-15T22:59:43.000Z","updated":"2020-05-18T13:36:13.573Z","comments":true,"path":"vue深入理解/Directives行为预设/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Directives%E8%A1%8C%E4%B8%BA%E9%A2%84%E8%AE%BE/","excerpt":"Directive我们通常叫它指令，在我的理解里Directives就是它是一组行为预设。前面我们不是有讲到Watcher嘛，Watcher作为中介者连接了数据和回调函数，但是我们的回调函数还是都是需要自己写一些操作的，实际上我们开发过程中有很多的重复性的操作，我们就将这一部分操作提取出来这就是Directive。现在这样是不是觉得指令这个名称很贴切呢，我们定义了指令告诉程序要做什么，而不是具体的谁要去做什么，这是一种抽象。","text":"Directive我们通常叫它指令，在我的理解里Directives就是它是一组行为预设。前面我们不是有讲到Watcher嘛，Watcher作为中介者连接了数据和回调函数，但是我们的回调函数还是都是需要自己写一些操作的，实际上我们开发过程中有很多的重复性的操作，我们就将这一部分操作提取出来这就是Directive。现在这样是不是觉得指令这个名称很贴切呢，我们定义了指令告诉程序要做什么，而不是具体的谁要去做什么，这是一种抽象。 Directive构造Directive需要一个descriptor对象，descriptor对象是我们在解析模板的时候根据相应的语法生成的一个描述对象，而Directive根据这个对象确定自己的具体类型。 descriptor对象中的def属性是定义的一些操作，通常都包括bind绑定以及update更新。Vue中默认提供了几种指令，同时我们也可以自定义指令。 加了下划线的(_bind、_update)是Directive类的抽象绑定方法，而没下划线(bind、update)的是由descriptor复制过来的具体的操作。 12345678910111213141516171819202122232425function Directive (descriptor, vm, el) &#123; this.vm = vm this.el = el this.descriptor = descriptor this.name = descriptor.name this.expression = descriptor.expression this.arg = descriptor.arg&#125;Directive.prototype._bind = function () &#123; var def = this.descriptor.def var attr = this.descriptor.attr || ('v-' + this.name) this.el.removeAttribute(attr) extend(this, def) if (this.bind) &#123; this.bind() &#125; if (this.expression &amp;&amp; this.update) &#123; var dir = this this._update = function (val, oldVal) &#123; dir.update(val, oldVal) &#125; this._watcher = new Watcher(this.vm, this.expression, this._update) &#125;&#125; Demo比如我们之前的表达式解析，我们就可以用指令去实现。 1234567891011121314151617181920212223242526272829303132333435var publicDirectives = &#123; text: &#123; bind () &#123; this.attr = this.el.nodeType === 3 ? 'data' : 'textContent' &#125;, update (value) &#123; this.el[this.attr] = value == null ? '' : value.toString() &#125; &#125;&#125;function compileTextNode (node) &#123; var tokens = parseText(node.wholeText) if (!tokens) &#123; return null &#125; var frag = document.createDocumentFragment() var el, token for (var i = 0, l = tokens.length; i &lt; l; i++) &#123; token = tokens[i] if (token.tag) &#123; el = document.createTextNode(' ') token.descriptor = &#123; name: 'text', def: publicDirectives['text'], expression: token.value, &#125; new Directive(token.descriptor, data, el); &#125; else &#123; el = document.createTextNode(token.value) &#125; frag.appendChild(el) &#125; replace(node, frag)&#125; 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Directives","slug":"Directives","permalink":"https://eagune.github.io/tags/Directives/"},{"name":"指令","slug":"指令","permalink":"https://eagune.github.io/tags/%E6%8C%87%E4%BB%A4/"},{"name":"行为预设","slug":"行为预设","permalink":"https://eagune.github.io/tags/%E8%A1%8C%E4%B8%BA%E9%A2%84%E8%AE%BE/"}]},{"title":"（六）表达式解析","slug":"vue深入理解/表达式解析","date":"2020-05-09T22:33:25.000Z","updated":"2020-05-18T13:36:13.573Z","comments":true,"path":"vue深入理解/表达式解析/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/","excerpt":"在前面我们将一个模板字符串转换成了DOM，但是并没有对其做任何处理，接下来要做的事情就是去识别文本插值以及各种指令。这一篇文章主要介绍使用“Mustache”语法 (双大括号) 的文本插值。","text":"在前面我们将一个模板字符串转换成了DOM，但是并没有对其做任何处理，接下来要做的事情就是去识别文本插值以及各种指令。这一篇文章主要介绍使用“Mustache”语法 (双大括号) 的文本插值。 compile首先我们要对每一个节点进行遍历，compileNodeList就是一个递归调用，如果节点下面有子节点就对其执行compileNodeList，这样我们就可以对每个节点进行compileNode处理。 在compileNode中我们分别对文本节点和元素节点进行处理，这一篇文章主要讲文本插值，所以我们只看文本节点。 1234567891011121314151617181920212223function compile(el)&#123; if (el.hasChildNodes()) &#123; compileNodeList(el.childNodes) &#125;&#125;function compileNodeList(nodeList)&#123; var node for (var i = 0, l = nodeList.length; i &lt; l; i++) &#123; node = nodeList[i] compileNode(node) if (node.hasChildNodes()) &#123; compileNodeList(node.childNodes) &#125; &#125;&#125;function compileNode (node) &#123; var type = node.nodeType if (type === 3 &amp;&amp; node.data.trim()) &#123; compileTextNode(node) &#125;&#125; 对文本节点的处理12345678910111213141516171819202122function compileTextNode (node) &#123; var tokens = parseText(node.wholeText) if (!tokens) &#123; return null &#125; var frag = document.createDocumentFragment() var el, token for (var i = 0, l = tokens.length; i &lt; l; i++) &#123; token = tokens[i] if (token.tag) &#123; el = document.createTextNode(' ') new Watcher(data, token.value, function(value, oldValue) &#123; var attr = el.nodeType === 3 ? 'data' : 'textContent'; el[attr] = value == null ? '' : value.toString() &#125;); &#125; else &#123; el = document.createTextNode(token.value) &#125; frag.appendChild(el) &#125; replace(node, frag)&#125; 工具方法12345678910111213141516171819202122232425262728293031323334353637383940function parseText (text) &#123; var tagRE = /\\&#123;\\&#123;((?:.|\\n)+?)\\&#125;\\&#125;/g // (?:.|\\n)中，.匹配换行符以外的字符 // 因为有的系统的换行符是\\r\\n // 所以.|\\n匹配除了\\r之外的任意字符 // ?:表示非捕获型括号，所以整个的就是匹配任意一个非\\r的字符 if (!tagRE.test(text)) &#123; return null &#125; var tokens = [] var lastIndex = tagRE.lastIndex = 0 // 在正则中lastIndex属性用于规定下次匹配的起始位置 // 因此我们每次匹配到后需要设置lastIndex为0下次才会匹配到正确的结果 var match, index, html, value while (match = tagRE.exec(text)) &#123; index = match.index // push text token if (index &gt; lastIndex) &#123; tokens.push(&#123; value: text.slice(lastIndex, index) &#125;) &#125; // tag token value = match[1] tokens.push(&#123; tag: true, value: value.trim(), &#125;) lastIndex = index + match[0].length &#125; if (lastIndex &lt; text.length) &#123; tokens.push(&#123; value: text.slice(lastIndex) &#125;) &#125; return tokens&#125;// 较源码省略了的地方：缓存、三重大括号显示html。 Demo查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"解析","slug":"解析","permalink":"https://eagune.github.io/tags/%E8%A7%A3%E6%9E%90/"},{"name":"表达式","slug":"表达式","permalink":"https://eagune.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"（五）模板字符串转换成DOM","slug":"vue深入理解/模板字符串转换成DOM","date":"2020-05-09T17:55:06.000Z","updated":"2020-05-18T13:36:13.573Z","comments":true,"path":"vue深入理解/模板字符串转换成DOM/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90DOM/","excerpt":"模板在前面的章节中我们已经知道了通过对数据进行劫持的方式可以让我们以这种通过数据驱动的方式去开发一个应用程序。但是如果全部在Watcher中做控制这样需要写很多重复性的控制视图的代码。 这样显然是很麻烦的，MVVM的核心是在MVC的基础上将view的状态行为抽象化。 在Vue中模板就是用来声明我们应用程序的数据与界面的绑定关系。 在Vue中模板不仅可以做到绑定数据还可以做到诸如循环判断等复杂功能，因此一定是一个图灵完备的语言去实现而不是html，它只是一种接近html的写法。 在Javascript中模板本质上也就是字符串，因此在Vue的运行过程中还需要将我们的模板字符串转换成DOM节点，并在这个过程中实现与我们数据的绑定。","text":"模板在前面的章节中我们已经知道了通过对数据进行劫持的方式可以让我们以这种通过数据驱动的方式去开发一个应用程序。但是如果全部在Watcher中做控制这样需要写很多重复性的控制视图的代码。 这样显然是很麻烦的，MVVM的核心是在MVC的基础上将view的状态行为抽象化。 在Vue中模板就是用来声明我们应用程序的数据与界面的绑定关系。 在Vue中模板不仅可以做到绑定数据还可以做到诸如循环判断等复杂功能，因此一定是一个图灵完备的语言去实现而不是html，它只是一种接近html的写法。 在Javascript中模板本质上也就是字符串，因此在Vue的运行过程中还需要将我们的模板字符串转换成DOM节点，并在这个过程中实现与我们数据的绑定。 stringToFragment为什么要将字符串转换为Fragment呢？因为频繁调用DOM的API会非常耗性能，而我们使用虚拟的节点对象会减少页面渲染dom的次数，效率会明显提升。 同时使用innerHTML让浏览器自行解析可以很方便的帮我们将字符串转换成合法的DOM节点，为我们后续的操作提供便利。 12345678910111213141516171819202122232425const tagRE = /&lt;([\\w:-]+)/const entityRE = /&amp;#?\\w+?;/const commentRE = /&lt;!--/function stringToFragment (templateString) &#123; var frag = document.createDocumentFragment() var tagMatch = templateString.match(tagRE) var entityMatch = entityRE.test(templateString) var commentMatch = commentRE.test(templateString) if (!tagMatch &amp;&amp; !entityMatch &amp;&amp; !commentMatch) &#123; // text only, return a single text node. frag.appendChild( document.createTextNode(templateString) ) &#125; else &#123; var node = document.createElement('div') node.innerHTML = templateString frag.appendChild(node) &#125; return frag&#125;// 较源码省略了的地方：诸如td、option等需要嵌套的标签如果直接使用生成的fragment并不会生效// 对于这种情况我们需要手动的拼接加上外层。 transclude我们将根节点的各种属性复制到根据模板生成的节点上，并替换掉html上的根节点。 1234567891011121314151617181920212223242526272829function init (el, template) &#123; var origin = el el = transcludeTemplate(el, template) replace(origin, el) return el&#125;function replace (target, el) &#123; var parent = target.parentNode if (parent) &#123; parent.replaceChild(el, target) &#125;&#125;function transcludeTemplate (el, template) &#123; var frag = stringToFragment(template) var replacer = frag.firstChild var attrs = el.attributes var i = attrs.length var name, value while (i--) &#123; name = attrs[i].name value = attrs[i].value if (!replacer.hasAttribute(name)) &#123; replacer.setAttribute(name, value) &#125; &#125; return replacer&#125; Demo查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"模板","slug":"模板","permalink":"https://eagune.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"转换","slug":"转换","permalink":"https://eagune.github.io/tags/%E8%BD%AC%E6%8D%A2/"},{"name":"Fragment","slug":"Fragment","permalink":"https://eagune.github.io/tags/Fragment/"}]},{"title":"（四）Dep依赖收集","slug":"vue深入理解/Dep依赖收集","date":"2020-04-26T09:58:52.000Z","updated":"2020-05-18T13:36:13.573Z","comments":true,"path":"vue深入理解/Dep依赖收集/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Dep%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/","excerpt":"通过Watcher我们可以定义一个数据和回调函数的关系，当我们的数据变化的时候执行对应的回调函数。 有的时候一个数据可能会对应很多的回调函数（即程序中很多地方都用到了某个数据），这时候我们就需要将这些依赖关系收集起来，当数据变化的时候统一执行回调函数。 Dep的定义Dep就是这样一个专门帮助我们管理依赖的类，它主要实现了依赖的收集、删除以及向依赖发送通知。同时我们可以将之前挂载到全局对象上的方法改为挂载到Dep上，避免污染全局作用域。","text":"通过Watcher我们可以定义一个数据和回调函数的关系，当我们的数据变化的时候执行对应的回调函数。 有的时候一个数据可能会对应很多的回调函数（即程序中很多地方都用到了某个数据），这时候我们就需要将这些依赖关系收集起来，当数据变化的时候统一执行回调函数。 Dep的定义Dep就是这样一个专门帮助我们管理依赖的类，它主要实现了依赖的收集、删除以及向依赖发送通知。同时我们可以将之前挂载到全局对象上的方法改为挂载到Dep上，避免污染全局作用域。 1234567891011121314151617181920function Dep () &#123; this.subs = []&#125;Dep.target = nullDep.prototype.depend = function () &#123; if (Dep.target) &#123; if (this.subs.indexOf(Dep.target) &gt; -1) &#123; this.subs.push(Dep.target) &#125; &#125;&#125;Dep.prototype.notify = function () &#123; var subs = this.subs for (var i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125;&#125; Dep的使用我们只需要将之前的Observer、defineReactive、mutator改造一下就可以实现依赖的收集和通知。我们给每一个属性构造一个Dep对象，当该属性触发取值的时候调用depend方法将依赖收集起来。同时如果这个属性的值是object或array的时候我们让子对象的Observer也把依赖添加进去，这很重要，因为数组的依赖就是在这里收集的，我们的mutator方法并不会触发defineReactive这里的依赖，而是触发在Observer收集的依赖。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function Observer (value) &#123; this.value = value this.dep = new Dep() def(value, '__ob__', this) if (Array.isArray(value)) &#123; value.__proto__ = arrayMethods; this.observeArray(value) &#125; else &#123; this.walk(value) &#125;&#125;function defineReactive(data, key, value) &#123; var dep = new Dep() var childOb = observe(value) Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() &#125; if (Array.isArray(value)) &#123; for (var e, i = 0, l = value.length; i &lt; l; i++) &#123; e = value[i] e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend() &#125; &#125; &#125; return value; &#125;, set: function(newVal) &#123; if (value === newVal) &#123; return; &#125; value = newVal; childOb = observe(newVal) dep.notify() &#125; &#125;);&#125;[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function(method) &#123; const original = arrayProto[method]; def(arrayMethods, method, function mutator () &#123; var i = arguments.length var args = new Array(i) while (i--) &#123; args[i] = arguments[i] &#125; var result = original.apply(this, args) var ob = this.__ob__ var inserted switch (method) &#123; case 'push': inserted = args break case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) ob.dep.notify() return result &#125;)&#125;) Demo查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Dep","slug":"Dep","permalink":"https://eagune.github.io/tags/Dep/"},{"name":"依赖收集","slug":"依赖收集","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/"}]},{"title":"（三）Watcher依赖数据的对象","slug":"vue深入理解/Watcher依赖数据的对象","date":"2020-04-25T13:33:50.000Z","updated":"2020-05-18T13:36:13.573Z","comments":true,"path":"vue深入理解/Watcher依赖数据的对象/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Watcher%E4%BE%9D%E8%B5%96%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E8%B1%A1/","excerpt":"如何利用变化侦测我们在前面已经做到了将一个对象上所有属性进行侦测，也就是说任何值改变我们都能知道。但是并没有将对应的方法暴露出来，也就是说不管更新在setter或者mutator中触发了，我们并不能再外部去调用方法去更新。 同时虽然取值的时候可以会触发getter，而在setter或者mutator中赋值的时候可以通知改变，但是有个问题是我们并不知道getter中是哪个方法或者对象调用的，因此我们就不知道去通知谁去更新。 为了解决这两个问题，我们需要定义一个依赖对象，这个对象有一个取值get方法，和一个update更新方法。当调用取值方法时可以触发getter，在取值前我们将这个对象挂载到一个全局的对象中，这样在触发getter方法时我们就可以通过全局对象获取到我们的依赖对象并将其收集起来，当触发setter或者mutator的时候我们就调用依赖对象的update方法实现更新操作。","text":"如何利用变化侦测我们在前面已经做到了将一个对象上所有属性进行侦测，也就是说任何值改变我们都能知道。但是并没有将对应的方法暴露出来，也就是说不管更新在setter或者mutator中触发了，我们并不能再外部去调用方法去更新。 同时虽然取值的时候可以会触发getter，而在setter或者mutator中赋值的时候可以通知改变，但是有个问题是我们并不知道getter中是哪个方法或者对象调用的，因此我们就不知道去通知谁去更新。 为了解决这两个问题，我们需要定义一个依赖对象，这个对象有一个取值get方法，和一个update更新方法。当调用取值方法时可以触发getter，在取值前我们将这个对象挂载到一个全局的对象中，这样在触发getter方法时我们就可以通过全局对象获取到我们的依赖对象并将其收集起来，当触发setter或者mutator的时候我们就调用依赖对象的update方法实现更新操作。 WatcherWatcher就是这样的一个依赖对象，它就像一个中介的角色，连接了最终的数据和回调函数。它的数据可以是一段路径表达式也可以是一个函数（expOrFn），我们将其定义成getter方法。 同时我们定义了一个get方法，在取值前先将Watcher对象挂载到全局对象上，调用它让依赖能被收集起来。 12345678910111213141516171819202122232425262728293031323334function Watcher (vm, expOrFn, cb, options) &#123; if (options) &#123; extend(this, options) &#125; this.vm = vm this.expression = expOrFn this.cb = cb if (typeof expOrFn === 'function') &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) &#125; this.value = this.get() this.shallow = false&#125;Watcher.prototype.get = function () &#123; window.target = this var value = this.getter.call(this.vm, this.vm) window.target = null return value&#125;Watcher.prototype.update = function () &#123; var value = this.get() if ( value !== this.value || ((isObject(value) || this.deep) &amp;&amp; !this.shallow) ) &#123; var oldValue = this.value this.value = value this.cb.call(this.vm, value, oldValue) &#125;&#125; 工具方法1234567891011121314151617181920212223function parsePath(path) &#123; const segments = path.split('.') //闭包保存层级数组 return function(obj) &#123; for (let i = 0; i &lt; segments.length; i++) &#123; if (!obj) return; obj = obj[segments[i]]; &#125; return obj; &#125;&#125;function isObject (obj) &#123; return obj !== null &amp;&amp; typeof obj === 'object'&#125;function extend (to, from) &#123; var keys = Object.keys(from) var i = keys.length while (i--) &#123; to[keys[i]] = from[keys[i]] &#125; return to&#125; parsePath： 使我们可以对更复杂的层级属性进行监听时（比如我们想侦测到data.a.b.c的时候）。 isObject： 检测一个值是否为对象。 extend： 可以将一个对象的属性拷贝到另一个对象上。 Demo查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Watcher","slug":"Watcher","permalink":"https://eagune.github.io/tags/Watcher/"},{"name":"依赖","slug":"依赖","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96/"}]},{"title":"（二）Observer将数据对象变成响应式","slug":"vue深入理解/Observer将数据对象变成响应式","date":"2020-04-25T09:43:39.000Z","updated":"2020-05-18T13:36:13.573Z","comments":true,"path":"vue深入理解/Observer将数据对象变成响应式/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Observer%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%88%90%E5%93%8D%E5%BA%94%E5%BC%8F/","excerpt":"通过前面的方法我们已经可以实现变化侦测的功能了，但是只做到了对数据对象中的某一个属性进行侦测，而我们希望对这个数据对象中的所有属性进行侦测，因此我们需要封装一个Observer类。 Observer12345678910111213141516171819202122232425262728293031var arrayKeys = Object.getOwnPropertyNames(arrayMethods)function Observer (value) &#123; this.value = value def(value, '__ob__', this) if (Array.isArray(value)) &#123; var augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) &#125; else &#123; this.walk(value) &#125;&#125;function observe (value) &#123; if (!value || typeof value !== 'object') &#123; return &#125; var ob if ( Object.prototype.hasOwnProperty.call(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer ) &#123; ob = value.__ob__ &#125; else if ( (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) ) &#123; ob = new Observer(value) &#125; return ob&#125; 首先我们在构造Observer的时候会给我们要观测对象添加一个__ob__属性，这个属性指向这个Observer。通过检查对象上的这个属性我们可以知道这个对象是否已经被观测过，从而避免重复的观测。","text":"通过前面的方法我们已经可以实现变化侦测的功能了，但是只做到了对数据对象中的某一个属性进行侦测，而我们希望对这个数据对象中的所有属性进行侦测，因此我们需要封装一个Observer类。 Observer12345678910111213141516171819202122232425262728293031var arrayKeys = Object.getOwnPropertyNames(arrayMethods)function Observer (value) &#123; this.value = value def(value, '__ob__', this) if (Array.isArray(value)) &#123; var augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) &#125; else &#123; this.walk(value) &#125;&#125;function observe (value) &#123; if (!value || typeof value !== 'object') &#123; return &#125; var ob if ( Object.prototype.hasOwnProperty.call(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer ) &#123; ob = value.__ob__ &#125; else if ( (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) ) &#123; ob = new Observer(value) &#125; return ob&#125; 首先我们在构造Observer的时候会给我们要观测对象添加一个__ob__属性，这个属性指向这个Observer。通过检查对象上的这个属性我们可以知道这个对象是否已经被观测过，从而避免重复的观测。 123456789101112131415161718192021222324252627282930Observer.prototype.observeArray = function (items) &#123; for (var i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125;&#125;Observer.prototype.walk = function (obj) &#123; var keys = Object.keys(obj) for (var i = 0, l = keys.length; i &lt; l; i++) &#123; defineReactive(this.value, keys[i], obj[keys[i]]) &#125;&#125;function defineReactive(data, key, value) &#123; var childOb = observe(value) Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; return value; &#125;, set: function(newVal) &#123; if (value === newVal) &#123; return; &#125; value = newVal; childOb = observe(newVal) &#125; &#125;);&#125; 然后我们判断这个值是数组还是对象。如果是数组那么给它应用上拦截器，并用observe方法遍历数组中的每一个值。如果是对象，我们就遍历这个对象上的每一个属性，将其转换为响应式的对象属性。 不管是数组还是对象属性在遍历的时候我们都对它的值进行了观测observe，如果这个值也是一个数组或对象，我们就继续构造一个Observer对象，通过这种递归调用的形式，我们就可以将对象上的所有属性包括子属性、数组中的值都侦测到。 工具方法12345678910111213141516171819202122232425function def (obj, key, val, enumerable) &#123; Object.defineProperty(obj, key, &#123; value: val, enumerable: !!enumerable, writable: true, configurable: true &#125;)&#125;function isPlainObject (obj) &#123; return Object.prototype.toString.call(obj) === '[object Object]'&#125;var hasProto = '__proto__' in &#123;&#125;function protoAugment (target, src) &#123; target.__proto__ = src&#125;function copyAugment (target, src, keys) &#123; for (var i = 0, l = keys.length; i &lt; l; i++) &#123; var key = keys[i] def(target, key, src[key]) &#125;&#125; def方法可以给对象添加一个属性，默认是不可枚举的。 isPlainObject则是用来严格检验一个对象是否是一个简单的JavaScript对象。 hasProto判断浏览器是否支持__proto__。 protoAugment设置目标的__proto__。 copyAugment将目标对象添加对应的属性。 Demo查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Observer","slug":"Observer","permalink":"https://eagune.github.io/tags/Observer/"},{"name":"响应式","slug":"响应式","permalink":"https://eagune.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"}]},{"title":"（一）Vue中变化侦测的原理","slug":"vue深入理解/Vue中变化侦测的原理","date":"2020-04-24T19:16:26.000Z","updated":"2020-05-18T13:36:13.573Z","comments":true,"path":"vue深入理解/Vue中变化侦测的原理/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Vue%E4%B8%AD%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"变化侦测变化侦测是实现响应式的核心。它的作用是当数据变化时，通知视图进行相应的更新。 我们的应用程序在运行时内部的状态会不断发生变化，而变化侦测就是检测到系统哪一个部分发生了变化。 比如在Angular中的脏检测，React中的虚拟DOM，而Vue中实现变化侦测的方式是对数据的劫持（元编程）。 这种方式的好处是在状态发生变化时，我们的程序就立马知道了，然后我们就可以对绑定了这个状态的所有依赖发送通知，让它们进行更新。 在javascript中使用Object.defineProperty可以侦测到一个对象的变化，然而它并不能侦测到数组中的变化，因此我们需要分别讨论。","text":"变化侦测变化侦测是实现响应式的核心。它的作用是当数据变化时，通知视图进行相应的更新。 我们的应用程序在运行时内部的状态会不断发生变化，而变化侦测就是检测到系统哪一个部分发生了变化。 比如在Angular中的脏检测，React中的虚拟DOM，而Vue中实现变化侦测的方式是对数据的劫持（元编程）。 这种方式的好处是在状态发生变化时，我们的程序就立马知道了，然后我们就可以对绑定了这个状态的所有依赖发送通知，让它们进行更新。 在javascript中使用Object.defineProperty可以侦测到一个对象的变化，然而它并不能侦测到数组中的变化，因此我们需要分别讨论。 Object的变化侦测我们定义一个defineReactive函数对Object.defineProperty进行封装，方便我们实现将对象中的某个数据转换成响应式的数据，每次从读取数据时会触发get函数，而每次设置数据时会触发set函数。 12345678910111213function defineReactive(obj, property, value) &#123; Object.defineProperty(obj, property, &#123; enumerable: true, configurable: true, get: function() &#123; return value; &#125;, set: function(newValue) &#123; if (newValue === value) return value = newValue; &#125;, &#125;)&#125; 查看DEMO Array的变化侦测在对Object进行变化侦测的时候是使用getter/setter的方式来进行追踪，然而对于数组类型，虽然读取数据时依然会触发get函数，但是并不能检测到我们通过push、pop等方法操作数组带来的改变。 因此我们采用另外一种方式实现变化侦测：拦截器。就是当我们调用数组的push、pop等方法的时候，先进入我们自定义的方法这样我们就可以知道这个变化，这时候我们在对依赖进行通知，然后调用数组的原始方法。 123456789101112131415161718192021const arrayProto = Array.prototype;const arrayMethods = Object.create(arrayProto);[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function(method) &#123; const original = arrayProto[method]; Object.defineProperty(arrayMethods, method, &#123; value: function mutator(...args) &#123;//使用rest参数可以避免将argumesnts对象转换为数组 return original.apply(this, args) &#125;, enumerable: false, //不让方法出现在枚举属性中 writable: true, configurable: true, &#125;)&#125;) 首先我们创建了arrayMethods对象来保存数组的原始方法，并对（push、pop、shift、unshift、splice、sort、reverse）这7种方法进行劫持。原理依然是我们调用这些方法的时候其实也是调用了原型对象上的一个属性，所以它依然可以触发这个属性的一个getter。 在使用的时候我们只希望我们对我们需要侦测数组进行劫持，所以我们不能覆盖Array.prototype，因此我们可以通过改变数据的__proto__指向我们的原型方法来实现。 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"变化侦测","slug":"变化侦测","permalink":"https://eagune.github.io/tags/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"},{"name":"defineReactive","slug":"defineReactive","permalink":"https://eagune.github.io/tags/defineReactive/"},{"name":"Object.defineProperty","slug":"Object-defineProperty","permalink":"https://eagune.github.io/tags/Object-defineProperty/"}]}],"categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"指令","slug":"指令","permalink":"https://eagune.github.io/tags/%E6%8C%87%E4%BB%A4/"},{"name":"解析","slug":"解析","permalink":"https://eagune.github.io/tags/%E8%A7%A3%E6%9E%90/"},{"name":"Directives","slug":"Directives","permalink":"https://eagune.github.io/tags/Directives/"},{"name":"行为预设","slug":"行为预设","permalink":"https://eagune.github.io/tags/%E8%A1%8C%E4%B8%BA%E9%A2%84%E8%AE%BE/"},{"name":"表达式","slug":"表达式","permalink":"https://eagune.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"模板","slug":"模板","permalink":"https://eagune.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"转换","slug":"转换","permalink":"https://eagune.github.io/tags/%E8%BD%AC%E6%8D%A2/"},{"name":"Fragment","slug":"Fragment","permalink":"https://eagune.github.io/tags/Fragment/"},{"name":"Dep","slug":"Dep","permalink":"https://eagune.github.io/tags/Dep/"},{"name":"依赖收集","slug":"依赖收集","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/"},{"name":"Watcher","slug":"Watcher","permalink":"https://eagune.github.io/tags/Watcher/"},{"name":"依赖","slug":"依赖","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96/"},{"name":"Observer","slug":"Observer","permalink":"https://eagune.github.io/tags/Observer/"},{"name":"响应式","slug":"响应式","permalink":"https://eagune.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"变化侦测","slug":"变化侦测","permalink":"https://eagune.github.io/tags/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"},{"name":"defineReactive","slug":"defineReactive","permalink":"https://eagune.github.io/tags/defineReactive/"},{"name":"Object.defineProperty","slug":"Object-defineProperty","permalink":"https://eagune.github.io/tags/Object-defineProperty/"}]}