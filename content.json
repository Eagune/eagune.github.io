{"meta":{"title":"Eagune's Blog","subtitle":"","description":"","author":"Eagune","url":"https://eagune.github.io","root":"/"},"pages":[{"title":"","date":"2020-05-13T15:45:15.997Z","updated":"2020-05-13T15:45:15.997Z","comments":true,"path":"index.html","permalink":"https://eagune.github.io/index.html","excerpt":"","text":""}],"posts":[{"title":"（六）表达式解析","slug":"vue深入理解/表达式解析","date":"2020-05-09T22:33:25.000Z","updated":"2020-05-13T15:45:15.949Z","comments":true,"path":"vue深入理解/表达式解析/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/","excerpt":"表达式解析","text":"表达式解析 parseText12345678910111213141516171819202122232425262728293031323334353637383940function parseText (text) &#123; var tagRE = /\\&#123;\\&#123;((?:.|\\n)+?)\\&#125;\\&#125;/g // (?:.|\\n)中，.匹配换行符以外的字符 // 因为有的系统的换行符是\\r\\n // 所以.|\\n匹配除了\\r之外的任意字符 // ?:表示非捕获型括号，所以整个的就是匹配任意一个非\\r的字符 if (!tagRE.test(text)) &#123; return null &#125; var tokens = [] var lastIndex = tagRE.lastIndex = 0 // 在正则中lastIndex属性用于规定下次匹配的起始位置 // 因此我们每次匹配到后需要设置lastIndex为0下次才会匹配到正确的结果 var match, index, html, value while (match = tagRE.exec(text)) &#123; index = match.index // push text token if (index &gt; lastIndex) &#123; tokens.push(&#123; value: text.slice(lastIndex, index) &#125;) &#125; // tag token value = match[1] tokens.push(&#123; tag: true, value: value.trim(), &#125;) lastIndex = index + match[0].length &#125; if (lastIndex &lt; text.length) &#123; tokens.push(&#123; value: text.slice(lastIndex) &#125;) &#125; return tokens&#125;// 较源码省略了的地方：缓存、三重大括号显示html。 compile12345678910111213141516171819202122232425262728293031323334353637383940414243444546function compile(el)&#123; if (el.hasChildNodes()) &#123; compileNodeList(el.childNodes) &#125;&#125;function compileNodeList(nodeList)&#123; var node for (var i = 0, l = nodeList.length; i &lt; l; i++) &#123; node = nodeList[i] compileNode(node) if (node.hasChildNodes()) &#123; compileNodeList(node.childNodes) &#125; &#125;&#125;function compileNode (node) &#123; var type = node.nodeType if (type === 3 &amp;&amp; node.data.trim()) &#123; compileTextNode(node) &#125;&#125;function compileTextNode (node) &#123; var tokens = parseText(node.wholeText) if (!tokens) &#123; return null &#125; var frag = document.createDocumentFragment() var el, token for (var i = 0, l = tokens.length; i &lt; l; i++) &#123; token = tokens[i] if (token.tag) &#123; el = document.createTextNode(' ') new Watcher(data, token.value, function(value, oldValue) &#123; var attr = el.nodeType === 3 ? 'data' : 'textContent'; el[attr] = value == null ? '' : value.toString() &#125;); &#125; else &#123; el = document.createTextNode(token.value) &#125; frag.appendChild(el) &#125; replace(node, frag)&#125; 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"表达式解析","slug":"表达式解析","permalink":"https://eagune.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/"}]},{"title":"（五）模板字符串转换成DOM","slug":"vue深入理解/模板字符串转换成DOM","date":"2020-05-09T17:55:06.000Z","updated":"2020-05-13T15:45:15.949Z","comments":true,"path":"vue深入理解/模板字符串转换成DOM/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90DOM/","excerpt":"模板在前面的章节中我们已经知道了通过对数据进行劫持的方式可以让我们以这种通过数据驱动的方式去开发一个应用程序。但是如果全部在Watcher中做控制这样需要写很多重复性的控制视图的代码。 这样显然是很麻烦的，MVVM的核心是在MVC的基础上将view的状态行为抽象化。 在Vue中模板就是用来声明我们应用程序的数据与界面的绑定关系。 在Vue中模板不仅可以做到绑定数据还可以做到诸如循环判断等复杂功能，因此一定是一个图灵完备的语言去实现而不是html，它只是一种接近html的写法。 在Javascript中模板本质上也就是字符串，因此在Vue的运行过程中还需要将我们的模板字符串转换成DOM节点，并在这个过程中实现与我们数据的绑定。","text":"模板在前面的章节中我们已经知道了通过对数据进行劫持的方式可以让我们以这种通过数据驱动的方式去开发一个应用程序。但是如果全部在Watcher中做控制这样需要写很多重复性的控制视图的代码。 这样显然是很麻烦的，MVVM的核心是在MVC的基础上将view的状态行为抽象化。 在Vue中模板就是用来声明我们应用程序的数据与界面的绑定关系。 在Vue中模板不仅可以做到绑定数据还可以做到诸如循环判断等复杂功能，因此一定是一个图灵完备的语言去实现而不是html，它只是一种接近html的写法。 在Javascript中模板本质上也就是字符串，因此在Vue的运行过程中还需要将我们的模板字符串转换成DOM节点，并在这个过程中实现与我们数据的绑定。 stringToFragment为什么要将字符串转换为Fragment呢？因为频繁调用DOM的API会非常耗性能，而我们使用虚拟的节点对象会减少页面渲染dom的次数，效率会明显提升。 同时使用innerHTML让浏览器自行解析可以很方便的帮我们将字符串转换成合法的DOM节点，为我们后续的操作提供便利。 12345678910111213141516171819202122232425const tagRE = /&lt;([\\w:-]+)/const entityRE = /&amp;#?\\w+?;/const commentRE = /&lt;!--/function stringToFragment (templateString) &#123; var frag = document.createDocumentFragment() var tagMatch = templateString.match(tagRE) var entityMatch = entityRE.test(templateString) var commentMatch = commentRE.test(templateString) if (!tagMatch &amp;&amp; !entityMatch &amp;&amp; !commentMatch) &#123; // text only, return a single text node. frag.appendChild( document.createTextNode(templateString) ) &#125; else &#123; var node = document.createElement('div') node.innerHTML = templateString frag.appendChild(node) &#125; return frag&#125;// 较源码省略了的地方：诸如td、option等需要嵌套的标签如果直接使用生成的fragment并不会生效// 对于这种情况我们需要手动的拼接加上外层。 transclude我们将根节点的各种属性复制到根据模板生成的节点上，并替换掉html上的根节点。 1234567891011121314151617181920212223242526272829function init (el, template) &#123; var origin = el el = transcludeTemplate(el, template) replace(origin, el) return el&#125;function replace (target, el) &#123; var parent = target.parentNode if (parent) &#123; parent.replaceChild(el, target) &#125;&#125;function transcludeTemplate (el, template) &#123; var frag = stringToFragment(template) var replacer = frag.firstChild var attrs = el.attributes var i = attrs.length var name, value while (i--) &#123; name = attrs[i].name value = attrs[i].value if (!replacer.hasAttribute(name)) &#123; replacer.setAttribute(name, value) &#125; &#125; return replacer&#125; 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"模板","slug":"模板","permalink":"https://eagune.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"转换","slug":"转换","permalink":"https://eagune.github.io/tags/%E8%BD%AC%E6%8D%A2/"},{"name":"Fragment","slug":"Fragment","permalink":"https://eagune.github.io/tags/Fragment/"}]},{"title":"（四）Dep依赖收集","slug":"vue深入理解/Dep依赖收集","date":"2020-04-26T09:58:52.000Z","updated":"2020-05-13T15:45:15.949Z","comments":true,"path":"vue深入理解/Dep依赖收集/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Dep%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/","excerpt":"封装Dep我们可以将defineReactive中收集依赖，通知依赖的命令式代码封装一下。","text":"封装Dep我们可以将defineReactive中收集依赖，通知依赖的命令式代码封装一下。 1234567891011121314151617class Dep &#123; constructor(value) &#123; this.subs = []; &#125; depend() &#123; if (window.target) &#123; this.subs.push(window.target); &#125; &#125; notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update(); &#125;) &#125;&#125; 在defineReactive中使用Dep123456789101112131415161718192021222324function defineReactive(data, key, value) &#123; if (typeof value === 'object') &#123; new Observer(value); &#125; let dep = new Dep(); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; dep.depend(); //新增 return value; &#125;, set: function(newVal) &#123; if (value === newVal) &#123; return; &#125; value = newVal; if (typeof value === 'object') &#123; new Observer(value); &#125; dep.notify(); //通知 &#125; &#125;);&#125; 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Dep","slug":"Dep","permalink":"https://eagune.github.io/tags/Dep/"},{"name":"依赖收集","slug":"依赖收集","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/"}]},{"title":"（三）Watcher依赖数据的对象","slug":"vue深入理解/Watcher依赖数据的对象","date":"2020-04-25T13:33:50.000Z","updated":"2020-05-13T15:45:15.949Z","comments":true,"path":"vue深入理解/Watcher依赖数据的对象/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Watcher%E4%BE%9D%E8%B5%96%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E8%B1%A1/","excerpt":"如何利用变化侦测我们在前面已经做到了将一个对象上所有属性进行侦测，也就是说任何值改变我们都能知道。但是并没有将对应的方法暴露出来，也就是说不管更新在setter或者mutator中触发了，我们并不能再外部去调用方法去更新。 同时虽然取值的时候可以会触发getter，而在setter或者mutator中赋值的时候可以通知改变，但是有个问题是我们并不知道getter中是哪个方法或者对象调用的，因此我们就不知道去通知谁去更新。 为了解决这两个问题，我们需要定义一个依赖对象，这个对象有一个取值get方法，和一个update更新方法。当调用取值方法时可以触发getter，在取值前我们将这个对象挂载到一个全局的对象中，这样在触发getter方法时我们就可以通过全局对象获取到我们的依赖对象并将其收集起来，当触发setter或者mutator的时候我们就调用依赖对象的update方法实现更新操作。","text":"如何利用变化侦测我们在前面已经做到了将一个对象上所有属性进行侦测，也就是说任何值改变我们都能知道。但是并没有将对应的方法暴露出来，也就是说不管更新在setter或者mutator中触发了，我们并不能再外部去调用方法去更新。 同时虽然取值的时候可以会触发getter，而在setter或者mutator中赋值的时候可以通知改变，但是有个问题是我们并不知道getter中是哪个方法或者对象调用的，因此我们就不知道去通知谁去更新。 为了解决这两个问题，我们需要定义一个依赖对象，这个对象有一个取值get方法，和一个update更新方法。当调用取值方法时可以触发getter，在取值前我们将这个对象挂载到一个全局的对象中，这样在触发getter方法时我们就可以通过全局对象获取到我们的依赖对象并将其收集起来，当触发setter或者mutator的时候我们就调用依赖对象的update方法实现更新操作。 WatcherWatcher就是这样的一个依赖对象，它就像一个中介的角色，连接了最终的数据和回调函数。它可以是一段路径表达式也可以是一个函数expOrFn，我们将其转换成Watcher的get方法，在构造时就调用一次让依赖能被收集起来。 12345678910111213141516171819202122232425262728293031323334function Watcher (vm, expOrFn, cb, options) &#123; if (options) &#123; extend(this, options) &#125; this.vm = vm this.expression = expOrFn this.cb = cb if (typeof expOrFn === 'function') &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) &#125; this.value = this.getter.call(this.vm) this.shallow = false&#125;Watcher.prototype.get = function () &#123; window.target = this var value = this.getter.call(this.vm) window.target = null return value&#125;Watcher.prototype.update = function () &#123; var value = this.get() if ( value !== this.value || ((isObject(value) || this.deep) &amp;&amp; !this.shallow) ) &#123; var oldValue = this.value this.value = value this.cb.call(this.vm, value, oldValue) &#125;&#125; 工具方法1234567891011121314151617181920212223function parsePath(path) &#123; const segments = path.split('.') //闭包保存层级数组 return function(obj) &#123; for (let i = 0; i &lt; segments.length; i++) &#123; if (!obj) return; obj = obj[segments[i]]; &#125; return obj; &#125;&#125;function isObject (obj) &#123; return obj !== null &amp;&amp; typeof obj === 'object'&#125;function extend (to, from) &#123; var keys = Object.keys(from) var i = keys.length while (i--) &#123; to[keys[i]] = from[keys[i]] &#125; return to&#125; parsePath： 使我们可以对更复杂的层级属性进行监听时（比如我们想侦测到data.a.b.c的时候）。 isObject： 检测一个值是否为对象。 extend： 可以将一个对象的属性拷贝到另一个对象上。","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Watcher","slug":"Watcher","permalink":"https://eagune.github.io/tags/Watcher/"},{"name":"依赖","slug":"依赖","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96/"}]},{"title":"（二）Observer将数据对象变成响应式","slug":"vue深入理解/Observer将数据对象变成响应式","date":"2020-04-25T09:43:39.000Z","updated":"2020-05-13T15:45:15.949Z","comments":true,"path":"vue深入理解/Observer将数据对象变成响应式/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Observer%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%88%90%E5%93%8D%E5%BA%94%E5%BC%8F/","excerpt":"通过前面的方法我们已经可以实现变化侦测的功能了，但是只做到了对数据对象中的某一个属性进行侦测，而我们希望对这个数据对象中的所有属性进行侦测，因此我们需要封装一个Observer类。 Observer1234567891011121314151617181920212223242526272829function Observer (value) &#123; this.value = value def(value, '__ob__', this) if (Array.isArray(value)) &#123; value.__proto__ = arrayMethods; this.observeArray(value) &#125; else &#123; this.walk(value) &#125;&#125;function observe (value) &#123; if (!value || typeof value !== 'object') &#123; return &#125; var ob if ( Object.prototype.hasOwnProperty.call(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer ) &#123; ob = value.__ob__ &#125; else if ( (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) ) &#123; ob = new Observer(value) &#125; return ob&#125; 首先我们在构造Observer的时候会给我们要观测对象添加一个__ob__属性，这个属性指向这个Observer。通过检查对象上的这个属性我们可以知道这个对象是否已经被观测过，从而避免重复的观测。","text":"通过前面的方法我们已经可以实现变化侦测的功能了，但是只做到了对数据对象中的某一个属性进行侦测，而我们希望对这个数据对象中的所有属性进行侦测，因此我们需要封装一个Observer类。 Observer1234567891011121314151617181920212223242526272829function Observer (value) &#123; this.value = value def(value, '__ob__', this) if (Array.isArray(value)) &#123; value.__proto__ = arrayMethods; this.observeArray(value) &#125; else &#123; this.walk(value) &#125;&#125;function observe (value) &#123; if (!value || typeof value !== 'object') &#123; return &#125; var ob if ( Object.prototype.hasOwnProperty.call(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer ) &#123; ob = value.__ob__ &#125; else if ( (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) ) &#123; ob = new Observer(value) &#125; return ob&#125; 首先我们在构造Observer的时候会给我们要观测对象添加一个__ob__属性，这个属性指向这个Observer。通过检查对象上的这个属性我们可以知道这个对象是否已经被观测过，从而避免重复的观测。 123456789101112131415161718192021222324252627282930Observer.prototype.observeArray = function (items) &#123; for (var i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125;&#125;Observer.prototype.walk = function (obj) &#123; var keys = Object.keys(obj) for (var i = 0, l = keys.length; i &lt; l; i++) &#123; defineReactive(this.value, keys[i], obj[keys[i]]) &#125;&#125;function defineReactive(data, key, value) &#123; var childOb = observe(value) Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; return value; &#125;, set: function(newVal) &#123; if (value === newVal) &#123; return; &#125; value = newVal; childOb = observe(newVal) &#125; &#125;);&#125; 然后我们判断这个值是数组还是对象。如果是数组那么给它应用上拦截器，并用observe方法遍历数组中的每一个值。如果是对象，我们就遍历这个对象上的每一个属性，将其转换为响应式的对象属性。 不管是数组还是对象属性在遍历的时候我们都对它的值进行了观测observe，如果这个值也是一个数组或对象，我们就继续构造一个Observer对象，通过这种递归调用的形式，我们就可以将对象上的所有属性包括子属性、数组中的值都侦测到。 工具方法123456789101112function def (obj, key, val, enumerable) &#123; Object.defineProperty(obj, key, &#123; value: val, enumerable: !!enumerable, writable: true, configurable: true &#125;)&#125;function isPlainObject (obj) &#123; return Object.prototype.toString.call(obj) === '[object Object]'&#125; def方法可以给对象添加一个属性，默认是不可枚举的。 isPlainObject则是用来严格检验一个对象是否是一个简单的JavaScript对象。 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Observer","slug":"Observer","permalink":"https://eagune.github.io/tags/Observer/"},{"name":"响应式","slug":"响应式","permalink":"https://eagune.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"}]},{"title":"（一）Vue中变化侦测的原理","slug":"vue深入理解/Vue中变化侦测的原理","date":"2020-04-24T19:16:26.000Z","updated":"2020-05-13T15:45:15.949Z","comments":true,"path":"vue深入理解/Vue中变化侦测的原理/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Vue%E4%B8%AD%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"变化侦测变化侦测是实现响应式的核心。它的作用是当数据变化时，通知视图进行相应的更新。 我们的应用程序在运行时内部的状态会不断发生变化，而变化侦测就是检测到系统哪一个部分发生了变化。 比如在Angular中的脏检测，React中的虚拟DOM，而Vue中实现变化侦测的方式是对数据的劫持（元编程）。 这种方式的好处是在状态发生变化时，我们的程序就立马知道了，然后我们就可以对绑定了这个状态的所有依赖发送通知，让它们进行更新。 在javascript中使用Object.defineProperty可以侦测到一个对象的变化，然而它并不能侦测到数组中的变化，因此我们需要分别讨论。","text":"变化侦测变化侦测是实现响应式的核心。它的作用是当数据变化时，通知视图进行相应的更新。 我们的应用程序在运行时内部的状态会不断发生变化，而变化侦测就是检测到系统哪一个部分发生了变化。 比如在Angular中的脏检测，React中的虚拟DOM，而Vue中实现变化侦测的方式是对数据的劫持（元编程）。 这种方式的好处是在状态发生变化时，我们的程序就立马知道了，然后我们就可以对绑定了这个状态的所有依赖发送通知，让它们进行更新。 在javascript中使用Object.defineProperty可以侦测到一个对象的变化，然而它并不能侦测到数组中的变化，因此我们需要分别讨论。 Object的变化侦测我们定义一个defineReactive函数对Object.defineProperty进行封装，方便我们实现将对象中的某个数据转换成响应式的数据，每次从读取数据时会触发get函数，而每次设置数据时会触发set函数。 12345678910111213function defineReactive(obj, property, value) &#123; Object.defineProperty(obj, property, &#123; enumerable: true, configurable: true, get: function() &#123; return value; &#125;, set: function(newValue) &#123; if (newValue === value) return value = newValue; &#125;, &#125;)&#125; 查看DEMO Array的变化侦测在对Object进行变化侦测的时候是使用getter/setter的方式来进行追踪，然而对于数组类型，虽然读取数据时依然会触发get函数，但是并不能检测到我们通过push、pop等方法操作数组带来的改变。 因此我们采用另外一种方式实现变化侦测：拦截器。就是当我们调用数组的push、pop等方法的时候，先进入我们自定义的方法这样我们就可以知道这个变化，这时候我们在对依赖进行通知，然后调用数组的原始方法。 123456789101112131415161718192021const arrayProto = Array.prototype;const arrayMethods = Object.create(arrayProto);[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function(method) &#123; const original = arrayProto[method]; Object.defineProperty(arrayMethods, method, &#123; value: function mutator(...args) &#123;//使用rest参数可以避免将argumesnts对象转换为数组 return original.apply(this, args) &#125;, enumerable: false, //不让方法出现在枚举属性中 writable: true, configurable: true, &#125;)&#125;) 首先我们创建了arrayMethods对象来保存数组的原始方法，并对（push、pop、shift、unshift、splice、sort、reverse）这7种方法进行劫持。原理依然是我们调用这些方法的时候其实也是调用了原型对象上的一个属性，所以它依然可以触发这个属性的一个getter。 在使用的时候我们只希望我们对我们需要侦测数组进行劫持，所以我们不能覆盖Array.prototype，因此我们可以通过改变数据的__proto__指向我们的原型方法来实现。 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"变化侦测","slug":"变化侦测","permalink":"https://eagune.github.io/tags/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"},{"name":"defineReactive","slug":"defineReactive","permalink":"https://eagune.github.io/tags/defineReactive/"},{"name":"Object.defineProperty","slug":"Object-defineProperty","permalink":"https://eagune.github.io/tags/Object-defineProperty/"}]}],"categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"表达式解析","slug":"表达式解析","permalink":"https://eagune.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/"},{"name":"模板","slug":"模板","permalink":"https://eagune.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"转换","slug":"转换","permalink":"https://eagune.github.io/tags/%E8%BD%AC%E6%8D%A2/"},{"name":"Fragment","slug":"Fragment","permalink":"https://eagune.github.io/tags/Fragment/"},{"name":"Dep","slug":"Dep","permalink":"https://eagune.github.io/tags/Dep/"},{"name":"依赖收集","slug":"依赖收集","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/"},{"name":"Watcher","slug":"Watcher","permalink":"https://eagune.github.io/tags/Watcher/"},{"name":"依赖","slug":"依赖","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96/"},{"name":"Observer","slug":"Observer","permalink":"https://eagune.github.io/tags/Observer/"},{"name":"响应式","slug":"响应式","permalink":"https://eagune.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"变化侦测","slug":"变化侦测","permalink":"https://eagune.github.io/tags/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"},{"name":"defineReactive","slug":"defineReactive","permalink":"https://eagune.github.io/tags/defineReactive/"},{"name":"Object.defineProperty","slug":"Object-defineProperty","permalink":"https://eagune.github.io/tags/Object-defineProperty/"}]}