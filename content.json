{"meta":{"title":"Eagune's Blog","subtitle":"","description":"","author":"Eagune","url":"https://eagune.github.io","root":"/"},"pages":[{"title":"","date":"2020-05-22T04:17:23.446Z","updated":"2020-05-22T04:17:23.446Z","comments":true,"path":"index.html","permalink":"https://eagune.github.io/index.html","excerpt":"","text":""}],"posts":[{"title":"（九）终端指令","slug":"vue深入理解/终端指令","date":"2020-05-22T00:21:26.000Z","updated":"2020-05-22T04:17:23.398Z","comments":true,"path":"vue深入理解/终端指令/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/%E7%BB%88%E7%AB%AF%E6%8C%87%E4%BB%A4/","excerpt":"终端指令有些指令我们希望在编译它之前先不要编译它的子节点，这种指令我们定义为终端指令即Terminal Directives。比如vIF、vFor这种都是终端指令。","text":"终端指令有些指令我们希望在编译它之前先不要编译它的子节点，这种指令我们定义为终端指令即Terminal Directives。比如vIF、vFor这种都是终端指令。 实现1234567function compileElement (el) &#123; var hasAttrs = el.hasAttributes() var attrs = hasAttrs &amp;&amp; toArray(el.attributes) if (!checkTerminalDirectives(el, attrs)) &#123; compileDirectives(el, attrs) &#125;&#125; 我们在compileDirectives之前加入了checkTerminalDirectives功能，checkTerminalDirectives首先遍历所有的指令然后解析，如果指令定义中的terminal属性为true，则该指令是一个终端指令，对于后续的指令解析不再进行。 12345678910111213141516171819202122232425262728293031function checkTerminalDirectives (el, attrs) &#123; // skip v-else block, but only if following v-if if (el.hasAttribute('v-else')) &#123; var prev = el.previousElementSibling if (prev &amp;&amp; prev.hasAttribute('v-if')) &#123; return skip &#125; &#125; var attr, name, value, matched, arg, def for (var i = 0, j = attrs.length; i &lt; j; i++) &#123; attr = attrs[i] name = attr.name if ((matched = name.match(dirAttrRE))) &#123; def = publicDirectives[matched[1]] if (def &amp;&amp; def.terminal) &#123; isTerminal = true var descriptor = &#123; name: matched[1], raw: attr.value, attr: attr.name, arg: matched[2], expression: attr.value, def: def &#125; vm._bindDir(descriptor, el) return true &#125; &#125; &#125; return false&#125;","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"终端指令","slug":"终端指令","permalink":"https://eagune.github.io/tags/%E7%BB%88%E7%AB%AF%E6%8C%87%E4%BB%A4/"}]},{"title":"【HTTP协议】请求行","slug":"网络协议/请求行","date":"2020-05-20T22:21:41.000Z","updated":"2020-05-22T04:17:23.398Z","comments":true,"path":"网络协议/请求行/","link":"","permalink":"https://eagune.github.io/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AF%B7%E6%B1%82%E8%A1%8C/","excerpt":"请求行request-line request-line = method SP request-target SP HTTP-version CRLF","text":"请求行request-line request-line = method SP request-target SP HTTP-version CRLF method常见方法 GET：主要获取信息的方法，幂等方法 HEAD：用于获取HEAD元数据，幂等方法 POST：用于提交FORM表单，新增资源等 PUT：更新资源，带条件时是幂等方法 DELETE：删除资源，幂等方法 CONNECT：建立tunnel隧道 OPTIONS：显示服务器对访问资源的支持方法，幂等方法 TRACE：回显服务器收到的请求，有安全风险 WEBDAV方法 PROPFIND： PROPPATCH： MKCOL： COPY: MOVE: LOCK: UNLOCK： request-target origin-form absolute-form authority-form asterisk-form","categories":[{"name":"网络协议","slug":"网络协议","permalink":"https://eagune.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://eagune.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://eagune.github.io/tags/HTTP%E5%8D%8F%E8%AE%AE/"},{"name":"请求行","slug":"请求行","permalink":"https://eagune.github.io/tags/%E8%AF%B7%E6%B1%82%E8%A1%8C/"}]},{"title":"【HTTP协议】URI","slug":"网络协议/URI","date":"2020-05-20T10:11:24.000Z","updated":"2020-05-22T04:17:23.398Z","comments":true,"path":"网络协议/URI/","link":"","permalink":"https://eagune.github.io/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/URI/","excerpt":"什么是URIURI是URL和URN的超集 URL（Uniform Resource Locator）：表示资源的位置，期望提供查找资源的方法，我们日常在浏览器中使用的URI其实也是URL。 URN（Uniform Resource Name）：表示资源的名字标识，比如磁力链接，期待用一个中心化的服务去解析这个名字标识然后解析到一个资源位置。","text":"什么是URIURI是URL和URN的超集 URL（Uniform Resource Locator）：表示资源的位置，期望提供查找资源的方法，我们日常在浏览器中使用的URI其实也是URL。 URN（Uniform Resource Name）：表示资源的名字标识，比如磁力链接，期待用一个中心化的服务去解析这个名字标识然后解析到一个资源位置。 URI的组成URI的组成：schema，user information，host，port，path，query，fragment URI的格式 URI = schema “:” hier-part [“?” query] [“#” fragment] schema = ALPHA *(ALPHA/DIGIT/“+”/“-“/“.”) hier-part = “//“ authority path authority = [userinfo “@”]host[“:” port] host = IP-literal/IPv4address/reg-name port = *DIGIT path = path-abempty/path-absolute/path-noscheme/path-rootless/path-empty query = *(pchar/“/“/“?”) fragment = *(pchar/“/“/“?”) URI的编码为什么要进行URI编码：可能存在做分隔符的保留字符，可能出现会产生歧义的数据编码。 编码方式：百分号编码方式","categories":[{"name":"网络协议","slug":"网络协议","permalink":"https://eagune.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://eagune.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://eagune.github.io/tags/HTTP%E5%8D%8F%E8%AE%AE/"},{"name":"URI","slug":"URI","permalink":"https://eagune.github.io/tags/URI/"}]},{"title":"网络分层","slug":"网络协议/网络分层","date":"2020-05-19T23:34:11.000Z","updated":"2020-05-22T04:17:23.398Z","comments":true,"path":"网络协议/网络分层/","link":"","permalink":"https://eagune.github.io/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82/","excerpt":"OSI模型OSI模型(Open System Interconnection Reference Model)，它是一个概念模型并没有真正的实现过，是用来指导我们理解网络协议的。 OSI模型把网络通信的工作分为7层,分别是物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。","text":"OSI模型OSI模型(Open System Interconnection Reference Model)，它是一个概念模型并没有真正的实现过，是用来指导我们理解网络协议的。 OSI模型把网络通信的工作分为7层,分别是物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。 1.物理层：各种物理设备的标准（比如布线、光纤、网卡），主要作用是传输比特流（1、0的二进制数据） 2.数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。 3.网络层：在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网，网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 4.传输层：传输层提供端对端的通信管理。主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。 5.会话层：会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。 6.表示层：表示层提供格式化的表示和转换数据服务（如数据的压缩和解压缩， 加密和解密等）。 7.应用层：应用层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。即程序需要的具体格式的数据，例如SMTP、DNS和FTP都是7层协议。 OSI模型与TCP/IP模型OSI模型只是一个概念模型，实际上在互联网中应用的是TCP/IP模型 网络分层的好处与坏处好处：本层的改动对其他层没有影响（比如在网络层IPv4升IPv6对于我们应用层没有任何的影响）。这样开发人员可以只关注整个结构中的一层更易于实现和维护，也可以很容易用新的实现代替旧的实践，降低了层与层之间的依赖，同时有利于标准化。 坏处：每一层传输都需要做处理，中间产生的数据延迟会导致性能下降。 网络分层在报文中的体现","categories":[{"name":"网络协议","slug":"网络协议","permalink":"https://eagune.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://eagune.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"OSI模型","slug":"OSI模型","permalink":"https://eagune.github.io/tags/OSI%E6%A8%A1%E5%9E%8B/"},{"name":"TCP/IP模型","slug":"TCP-IP模型","permalink":"https://eagune.github.io/tags/TCP-IP%E6%A8%A1%E5%9E%8B/"}]},{"title":"（八）指令解析","slug":"vue深入理解/指令解析","date":"2020-05-16T20:42:31.000Z","updated":"2020-05-22T04:17:23.398Z","comments":true,"path":"vue深入理解/指令解析/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90/","excerpt":"指令解析指令的解析和之前的文本解析差不多，我们都需要遍历节点最后执行compileNode进行解析，这里我们加一个判断如果节点是元素我们就进入我们的指令解析compileDirectives。","text":"指令解析指令的解析和之前的文本解析差不多，我们都需要遍历节点最后执行compileNode进行解析，这里我们加一个判断如果节点是元素我们就进入我们的指令解析compileDirectives。 1234567891011121314function compileNode (node) &#123; var type = node.nodeType if (type === 1) &#123; return compileElement(node) &#125; else if (type === 3 &amp;&amp; node.data.trim()) &#123; compileTextNode(node) &#125;&#125;function compileElement (el) &#123; var hasAttrs = el.hasAttributes() var attrs = hasAttrs &amp;&amp; toArray(el.attributes) compileDirectives(el, attrs)&#125; 重点是这个compileDirectives，对于v-on指令和v-bind指令由于他们有特殊的绑定格式所以需要单独拿出来，其中bind指令对于style和class的绑定的处理也不一样，都需要分别进行处理，最后才是通用的指令解析。 1234567891011121314151617181920212223242526272829303132333435363738394041424344var onRE = /^v-on:|^@/var bindRE = /^v-bind:|^:/var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/function compileDirectives (el, attrs) &#123; var i = attrs.length var dirs = [] var attr, name, rawName, rawValue, value, dirName, arg, dirDef, matched while (i--) &#123; attr = attrs[i] name = rawName = attr.name value = rawValue = attr.value var descriptor = &#123; attr: rawName, raw: rawValue, expression: value &#125; if (onRE.test(name)) &#123; descriptor.name = 'on' arg = name.replace(onRE, '') dirDef = publicDirectives.on &#125; else if (bindRE.test(name)) &#123; descriptor.name = 'bind' arg = dirName = name.replace(bindRE, '') if (dirName === 'style' || dirName === 'class') &#123; dirDef = internalDirectives[dirName] &#125; else &#123; dirDef = publicDirectives.bind &#125; &#125; else if ((matched = name.match(dirAttrRE))) &#123; dirName = matched[1] arg = matched[2] // skip v-else (when used with v-show) if (dirName === 'else') &#123; continue &#125; dirDef = publicDirectives[dirName] &#125; if (dirDef) &#123; descriptor.arg = arg descriptor.def = dirDef new Directive(descriptor, el) &#125; &#125;&#125; 下面我们看看这些指令的具体行为： v-on指令on指令的话比较简单，在descriptor中arg就是我们事件名称，值对应vm中的函数名称，当这个值发生变化的时候首先重置如果之前添加了事件则先移除旧的事件，然后添加事件侦听。 1234567891011121314151617181920212223242526function on (el, event, cb, useCapture) &#123; el.addEventListener(event, cb, useCapture)&#125;function off (el, event, cb) &#123; el.removeEventListener(event, cb)&#125;var publicDirectives = &#123; on: &#123; update (handler) &#123; if (!this.descriptor.raw) &#123; handler = function () &#123;&#125; &#125; var vm = this.vm // reset if (this.handler) &#123; off(this.el, this.arg, this.handler) &#125; this.handler = function (e) &#123; return handler.call(vm, e) &#125; on(this.el, this.arg, this.handler) &#125;, &#125;&#125; 查看DEMO v-bind指令对于一般的bind指令 对于value|checked|selected等属性我们不仅需要修改属性的值同时我们还需要修改元素节点上对应的值 对于draggable|contenteditable|spellcheck这种枚举型的值我们只允许true和false 1234567891011121314151617181920212223242526272829var attrWithPropsRE = /^(?:value|checked|selected|muted)$/var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/var publicDirectives = &#123; bind: &#123; update (value) &#123; var attr = this.arg if (this.arg) &#123; this.handleSingle(attr, value) &#125; &#125;, handleSingle (prop, value) &#123; if (attrWithPropsRE.test(attr) &amp;&amp; attr in el) &#123; var attrValue = attr === 'value' ? value == null ? '' : value : value if (el[attr] !== attrValue) &#123; el[attr] = attrValue &#125; &#125; if (enumeratedAttrRE.test(attr)) &#123; el.setAttribute(attr, value ? 'true' : 'false') &#125; else if (value != null &amp;&amp; value !== false) &#123; el.setAttribute(attr, value === true ? '' : value) &#125; else &#123; el.removeAttribute(attr) &#125; &#125; &#125;&#125; 对于style指令style指令支持字符串、数组、对象。如果是字符串直接修改cssText，如果是数组则先把所有属性合并成一个对象，最后处理和对象的处理是一样的。 handleObject将指令绑定对象的所有的属性缓存起来，只有当发生变化的属性才做处理，同时如果属性被移除了也要做相应的处理。 1234567891011121314151617181920212223242526272829303132333435363738394041var internalDirectives = &#123; style: &#123; update (value) &#123; if (typeof value === 'string') &#123; this.el.style.cssText = value &#125; else if (Array.isArray(value)) &#123; this.handleObject(value.reduce(extend, &#123;&#125;)) &#125; else &#123; this.handleObject(value || &#123;&#125;) &#125; &#125;, handleObject (value) &#123; // cache object styles so that only changed props // are actually updated. var cache = this.cache || (this.cache = &#123;&#125;) var name, val for (name in cache) &#123; if (!(name in value)) &#123; this.handleSingle(name, null) delete cache[name] &#125; &#125; for (name in value) &#123; val = value[name] if (val !== cache[name]) &#123; cache[name] = val this.handleSingle(name, val) &#125; &#125; &#125;, handleSingle (prop, value) &#123; // cast possible numbers/booleans into strings if (value != null) value += '' if (value) &#123; this.el.style[prop] = value &#125; else &#123; this.el.style[prop] = '' &#125; &#125; &#125;&#125; 对于class指令如果绑定值为空了，那么我们把之前的class也清空，如果绑定值是字符串，我们根据空格分隔转化为className数组然后设置为新的class，对于数组或对象的形式我们先执行normalize转换成相应的className数组然后设置为新的class。 12345678910111213141516171819202122232425262728293031323334var internalDirectives = &#123; class: &#123; update (value) &#123; if (!value) &#123; this.cleanup() &#125; else if (typeof value === 'string') &#123; this.setClass(value.trim().split(/\\s+/)) &#125; else &#123; this.setClass(normalize(value)) &#125; &#125;, setClass (value) &#123; this.cleanup(value) for (var i = 0, l = value.length; i &lt; l; i++) &#123; var val = value[i] if (val) &#123; apply(this.el, val, addClass) &#125; &#125; this.prevKeys = value &#125;, cleanup (value) &#123; const prevKeys = this.prevKeys if (!prevKeys) return var i = prevKeys.length while (i--) &#123; var key = prevKeys[i] if (!value || value.indexOf(key) &lt; 0) &#123; apply(this.el, key, removeClass) &#125; &#125; &#125; &#125;&#125; normalize对于数组的每一项先判断是否是字符串，如果是字符串那么直接加入结果，如果是对象的形式则遍历每一项加入，对于对象则直接遍历加入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function normalize (value) &#123; const res = [] if (isArray(value)) &#123; for (var i = 0, l = value.length; i &lt; l; i++) &#123; const key = value[i] if (key) &#123; if (typeof key === 'string') &#123; res.push(key) &#125; else &#123; for (var k in key) &#123; if (key[k]) res.push(k) &#125; &#125; &#125; &#125; &#125; else if (isObject(value)) &#123; for (var key in value) &#123; if (value[key]) res.push(key) &#125; &#125; return res&#125;function setClass (el, cls) &#123; if (isIE9 &amp;&amp; !/svg$/.test(el.namespaceURI)) &#123; el.className = cls &#125; else &#123; el.setAttribute('class', cls) &#125;&#125;function addClass (el, cls) &#123; if (el.classList) &#123; el.classList.add(cls) &#125; else &#123; var cur = ' ' + getClass(el) + ' ' if (cur.indexOf(' ' + cls + ' ') &lt; 0) &#123; setClass(el, (cur + cls).trim()) &#125; &#125;&#125;function removeClass (el, cls) &#123; if (el.classList) &#123; el.classList.remove(cls) &#125; else &#123; var cur = ' ' + getClass(el) + ' ' var tar = ' ' + cls + ' ' while (cur.indexOf(tar) &gt;= 0) &#123; cur = cur.replace(tar, ' ') &#125; setClass(el, cur.trim()) &#125; if (!el.className) &#123; el.removeAttribute('class') &#125;&#125;function apply (el, key, fn) &#123; key = key.trim() if (key.indexOf(' ') === -1) &#123; fn(el, key) return &#125; // The key contains one or more space characters. // Since a class name doesn't accept such characters, we // treat it as multiple classes. var keys = key.split(/\\s+/) for (var i = 0, l = keys.length; i &lt; l; i++) &#123; fn(el, keys[i]) &#125;&#125; Demo查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"指令","slug":"指令","permalink":"https://eagune.github.io/tags/%E6%8C%87%E4%BB%A4/"},{"name":"解析","slug":"解析","permalink":"https://eagune.github.io/tags/%E8%A7%A3%E6%9E%90/"}]},{"title":"（七）Directives行为预设","slug":"vue深入理解/Directives行为预设","date":"2020-05-15T22:59:43.000Z","updated":"2020-05-22T04:17:23.398Z","comments":true,"path":"vue深入理解/Directives行为预设/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Directives%E8%A1%8C%E4%B8%BA%E9%A2%84%E8%AE%BE/","excerpt":"Directive我们通常叫它指令，在我的理解里Directives就是它是一组行为预设。前面我们不是有讲到Watcher嘛，Watcher作为中介者连接了数据和回调函数，但是我们的回调函数还是都是需要自己写一些操作的，实际上我们开发过程中有很多的重复性的操作，我们就将这一部分操作提取出来这就是Directive。现在这样是不是觉得指令这个名称很贴切呢，我们定义了指令告诉程序要做什么，而不是具体的谁要去做什么，这是一种抽象。","text":"Directive我们通常叫它指令，在我的理解里Directives就是它是一组行为预设。前面我们不是有讲到Watcher嘛，Watcher作为中介者连接了数据和回调函数，但是我们的回调函数还是都是需要自己写一些操作的，实际上我们开发过程中有很多的重复性的操作，我们就将这一部分操作提取出来这就是Directive。现在这样是不是觉得指令这个名称很贴切呢，我们定义了指令告诉程序要做什么，而不是具体的谁要去做什么，这是一种抽象。 Directive构造Directive需要一个descriptor对象，descriptor对象是我们在解析模板的时候根据相应的语法生成的一个描述对象，而Directive根据这个对象确定自己的具体类型。 descriptor对象中的def属性是定义的一些操作，通常都包括bind绑定以及update更新。Vue中默认提供了几种指令，同时我们也可以自定义指令。 加了下划线的(_bind、_update)是Directive类的抽象绑定方法，而没下划线(bind、update)的是由descriptor复制过来的具体的操作。 12345678910111213141516171819202122232425function Directive (descriptor, vm, el) &#123; this.vm = vm this.el = el this.descriptor = descriptor this.name = descriptor.name this.expression = descriptor.expression this.arg = descriptor.arg&#125;Directive.prototype._bind = function () &#123; var def = this.descriptor.def var attr = this.descriptor.attr || ('v-' + this.name) this.el.removeAttribute(attr) extend(this, def) if (this.bind) &#123; this.bind() &#125; if (this.expression &amp;&amp; this.update) &#123; var dir = this this._update = function (val, oldVal) &#123; dir.update(val, oldVal) &#125; this._watcher = new Watcher(this.vm, this.expression, this._update) &#125;&#125; Demo比如我们之前的表达式解析，我们就可以用指令去实现。 1234567891011121314151617181920212223242526272829303132333435var publicDirectives = &#123; text: &#123; bind () &#123; this.attr = this.el.nodeType === 3 ? 'data' : 'textContent' &#125;, update (value) &#123; this.el[this.attr] = value == null ? '' : value.toString() &#125; &#125;&#125;function compileTextNode (node) &#123; var tokens = parseText(node.wholeText) if (!tokens) &#123; return null &#125; var frag = document.createDocumentFragment() var el, token for (var i = 0, l = tokens.length; i &lt; l; i++) &#123; token = tokens[i] if (token.tag) &#123; el = document.createTextNode(' ') token.descriptor = &#123; name: 'text', def: publicDirectives['text'], expression: token.value, &#125; new Directive(token.descriptor, data, el); &#125; else &#123; el = document.createTextNode(token.value) &#125; frag.appendChild(el) &#125; replace(node, frag)&#125; 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Directives","slug":"Directives","permalink":"https://eagune.github.io/tags/Directives/"},{"name":"指令","slug":"指令","permalink":"https://eagune.github.io/tags/%E6%8C%87%E4%BB%A4/"},{"name":"行为预设","slug":"行为预设","permalink":"https://eagune.github.io/tags/%E8%A1%8C%E4%B8%BA%E9%A2%84%E8%AE%BE/"}]},{"title":"（六）表达式解析","slug":"vue深入理解/表达式解析","date":"2020-05-09T22:33:25.000Z","updated":"2020-05-22T04:17:23.398Z","comments":true,"path":"vue深入理解/表达式解析/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/","excerpt":"在前面我们将一个模板字符串转换成了DOM，但是并没有对其做任何处理，接下来要做的事情就是去识别文本插值以及各种指令。这一篇文章主要介绍使用“Mustache”语法 (双大括号) 的文本插值。","text":"在前面我们将一个模板字符串转换成了DOM，但是并没有对其做任何处理，接下来要做的事情就是去识别文本插值以及各种指令。这一篇文章主要介绍使用“Mustache”语法 (双大括号) 的文本插值。 compile首先我们要对每一个节点进行遍历，compileNodeList就是一个递归调用，如果节点下面有子节点就对其执行compileNodeList，这样我们就可以对每个节点进行compileNode处理。 在compileNode中我们分别对文本节点和元素节点进行处理，这一篇文章主要讲文本插值，所以我们只看文本节点。 1234567891011121314151617181920212223function compile(el)&#123; if (el.hasChildNodes()) &#123; compileNodeList(el.childNodes) &#125;&#125;function compileNodeList(nodeList)&#123; var node for (var i = 0, l = nodeList.length; i &lt; l; i++) &#123; node = nodeList[i] compileNode(node) if (node.hasChildNodes()) &#123; compileNodeList(node.childNodes) &#125; &#125;&#125;function compileNode (node) &#123; var type = node.nodeType if (type === 3 &amp;&amp; node.data.trim()) &#123; compileTextNode(node) &#125;&#125; 对文本节点的处理12345678910111213141516171819202122function compileTextNode (node) &#123; var tokens = parseText(node.wholeText) if (!tokens) &#123; return null &#125; var frag = document.createDocumentFragment() var el, token for (var i = 0, l = tokens.length; i &lt; l; i++) &#123; token = tokens[i] if (token.tag) &#123; el = document.createTextNode(' ') new Watcher(data, token.value, function(value, oldValue) &#123; var attr = el.nodeType === 3 ? 'data' : 'textContent'; el[attr] = value == null ? '' : value.toString() &#125;); &#125; else &#123; el = document.createTextNode(token.value) &#125; frag.appendChild(el) &#125; replace(node, frag)&#125; 工具方法12345678910111213141516171819202122232425262728293031323334353637383940function parseText (text) &#123; var tagRE = /\\&#123;\\&#123;((?:.|\\n)+?)\\&#125;\\&#125;/g // (?:.|\\n)中，.匹配换行符以外的字符 // 因为有的系统的换行符是\\r\\n // 所以.|\\n匹配除了\\r之外的任意字符 // ?:表示非捕获型括号，所以整个的就是匹配任意一个非\\r的字符 if (!tagRE.test(text)) &#123; return null &#125; var tokens = [] var lastIndex = tagRE.lastIndex = 0 // 在正则中lastIndex属性用于规定下次匹配的起始位置 // 因此我们每次匹配到后需要设置lastIndex为0下次才会匹配到正确的结果 var match, index, html, value while (match = tagRE.exec(text)) &#123; index = match.index // push text token if (index &gt; lastIndex) &#123; tokens.push(&#123; value: text.slice(lastIndex, index) &#125;) &#125; // tag token value = match[1] tokens.push(&#123; tag: true, value: value.trim(), &#125;) lastIndex = index + match[0].length &#125; if (lastIndex &lt; text.length) &#123; tokens.push(&#123; value: text.slice(lastIndex) &#125;) &#125; return tokens&#125;// 较源码省略了的地方：缓存、三重大括号显示html。 Demo查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"表达式","slug":"表达式","permalink":"https://eagune.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"解析","slug":"解析","permalink":"https://eagune.github.io/tags/%E8%A7%A3%E6%9E%90/"}]},{"title":"（五）模板字符串转换成DOM","slug":"vue深入理解/模板字符串转换成DOM","date":"2020-05-09T17:55:06.000Z","updated":"2020-05-22T04:17:23.398Z","comments":true,"path":"vue深入理解/模板字符串转换成DOM/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90DOM/","excerpt":"模板在前面的章节中我们已经知道了通过对数据进行劫持的方式可以让我们以这种通过数据驱动的方式去开发一个应用程序。但是如果全部在Watcher中做控制这样需要写很多重复性的控制视图的代码。 这样显然是很麻烦的，MVVM的核心是在MVC的基础上将view的状态行为抽象化。 在Vue中模板就是用来声明我们应用程序的数据与界面的绑定关系。 在Vue中模板不仅可以做到绑定数据还可以做到诸如循环判断等复杂功能，因此一定是一个图灵完备的语言去实现而不是html，它只是一种接近html的写法。 在Javascript中模板本质上也就是字符串，因此在Vue的运行过程中还需要将我们的模板字符串转换成DOM节点，并在这个过程中实现与我们数据的绑定。","text":"模板在前面的章节中我们已经知道了通过对数据进行劫持的方式可以让我们以这种通过数据驱动的方式去开发一个应用程序。但是如果全部在Watcher中做控制这样需要写很多重复性的控制视图的代码。 这样显然是很麻烦的，MVVM的核心是在MVC的基础上将view的状态行为抽象化。 在Vue中模板就是用来声明我们应用程序的数据与界面的绑定关系。 在Vue中模板不仅可以做到绑定数据还可以做到诸如循环判断等复杂功能，因此一定是一个图灵完备的语言去实现而不是html，它只是一种接近html的写法。 在Javascript中模板本质上也就是字符串，因此在Vue的运行过程中还需要将我们的模板字符串转换成DOM节点，并在这个过程中实现与我们数据的绑定。 stringToFragment为什么要将字符串转换为Fragment呢？因为频繁调用DOM的API会非常耗性能，而我们使用虚拟的节点对象会减少页面渲染dom的次数，效率会明显提升。 同时使用innerHTML让浏览器自行解析可以很方便的帮我们将字符串转换成合法的DOM节点，为我们后续的操作提供便利。 12345678910111213141516171819202122232425const tagRE = /&lt;([\\w:-]+)/const entityRE = /&amp;#?\\w+?;/const commentRE = /&lt;!--/function stringToFragment (templateString) &#123; var frag = document.createDocumentFragment() var tagMatch = templateString.match(tagRE) var entityMatch = entityRE.test(templateString) var commentMatch = commentRE.test(templateString) if (!tagMatch &amp;&amp; !entityMatch &amp;&amp; !commentMatch) &#123; // text only, return a single text node. frag.appendChild( document.createTextNode(templateString) ) &#125; else &#123; var node = document.createElement('div') node.innerHTML = templateString frag.appendChild(node) &#125; return frag&#125;// 较源码省略了的地方：诸如td、option等需要嵌套的标签如果直接使用生成的fragment并不会生效// 对于这种情况我们需要手动的拼接加上外层。 transclude我们将根节点的各种属性复制到根据模板生成的节点上，并替换掉html上的根节点。 1234567891011121314151617181920212223242526272829function init (el, template) &#123; var origin = el el = transcludeTemplate(el, template) replace(origin, el) return el&#125;function replace (target, el) &#123; var parent = target.parentNode if (parent) &#123; parent.replaceChild(el, target) &#125;&#125;function transcludeTemplate (el, template) &#123; var frag = stringToFragment(template) var replacer = frag.firstChild var attrs = el.attributes var i = attrs.length var name, value while (i--) &#123; name = attrs[i].name value = attrs[i].value if (!replacer.hasAttribute(name)) &#123; replacer.setAttribute(name, value) &#125; &#125; return replacer&#125; Demo查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"模板","slug":"模板","permalink":"https://eagune.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"转换","slug":"转换","permalink":"https://eagune.github.io/tags/%E8%BD%AC%E6%8D%A2/"},{"name":"Fragment","slug":"Fragment","permalink":"https://eagune.github.io/tags/Fragment/"}]},{"title":"（四）Dep依赖收集","slug":"vue深入理解/Dep依赖收集","date":"2020-04-26T09:58:52.000Z","updated":"2020-05-22T04:17:23.398Z","comments":true,"path":"vue深入理解/Dep依赖收集/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Dep%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/","excerpt":"通过Watcher我们可以定义一个数据和回调函数的关系，当我们的数据变化的时候执行对应的回调函数。 有的时候一个数据可能会对应很多的回调函数（即程序中很多地方都用到了某个数据），这时候我们就需要将这些依赖关系收集起来，当数据变化的时候统一执行回调函数。 Dep的定义Dep就是这样一个专门帮助我们管理依赖的类，它主要实现了依赖的收集、删除以及向依赖发送通知。同时我们可以将之前挂载到全局对象上的方法改为挂载到Dep上，避免污染全局作用域。","text":"通过Watcher我们可以定义一个数据和回调函数的关系，当我们的数据变化的时候执行对应的回调函数。 有的时候一个数据可能会对应很多的回调函数（即程序中很多地方都用到了某个数据），这时候我们就需要将这些依赖关系收集起来，当数据变化的时候统一执行回调函数。 Dep的定义Dep就是这样一个专门帮助我们管理依赖的类，它主要实现了依赖的收集、删除以及向依赖发送通知。同时我们可以将之前挂载到全局对象上的方法改为挂载到Dep上，避免污染全局作用域。 1234567891011121314151617181920function Dep () &#123; this.subs = []&#125;Dep.target = nullDep.prototype.depend = function () &#123; if (Dep.target) &#123; if (this.subs.indexOf(Dep.target) &gt; -1) &#123; this.subs.push(Dep.target) &#125; &#125;&#125;Dep.prototype.notify = function () &#123; var subs = this.subs for (var i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125;&#125; Dep的使用我们只需要将之前的Observer、defineReactive、mutator改造一下就可以实现依赖的收集和通知。我们给每一个属性构造一个Dep对象，当该属性触发取值的时候调用depend方法将依赖收集起来。同时如果这个属性的值是object或array的时候我们让子对象的Observer也把依赖添加进去，这很重要，因为数组的依赖就是在这里收集的，我们的mutator方法并不会触发defineReactive这里的依赖，而是触发在Observer收集的依赖。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function Observer (value) &#123; this.value = value this.dep = new Dep() def(value, '__ob__', this) if (Array.isArray(value)) &#123; value.__proto__ = arrayMethods; this.observeArray(value) &#125; else &#123; this.walk(value) &#125;&#125;function defineReactive(data, key, value) &#123; var dep = new Dep() var childOb = observe(value) Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() &#125; if (Array.isArray(value)) &#123; for (var e, i = 0, l = value.length; i &lt; l; i++) &#123; e = value[i] e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend() &#125; &#125; &#125; return value; &#125;, set: function(newVal) &#123; if (value === newVal) &#123; return; &#125; value = newVal; childOb = observe(newVal) dep.notify() &#125; &#125;);&#125;[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function(method) &#123; const original = arrayProto[method]; def(arrayMethods, method, function mutator () &#123; var i = arguments.length var args = new Array(i) while (i--) &#123; args[i] = arguments[i] &#125; var result = original.apply(this, args) var ob = this.__ob__ var inserted switch (method) &#123; case 'push': inserted = args break case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) ob.dep.notify() return result &#125;)&#125;) Demo查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Dep","slug":"Dep","permalink":"https://eagune.github.io/tags/Dep/"},{"name":"依赖收集","slug":"依赖收集","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/"}]},{"title":"（三）Watcher依赖数据的对象","slug":"vue深入理解/Watcher依赖数据的对象","date":"2020-04-25T13:33:50.000Z","updated":"2020-05-22T04:17:23.398Z","comments":true,"path":"vue深入理解/Watcher依赖数据的对象/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Watcher%E4%BE%9D%E8%B5%96%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E8%B1%A1/","excerpt":"如何利用变化侦测我们在前面已经做到了将一个对象上所有属性进行侦测，也就是说任何值改变我们都能知道。但是并没有将对应的方法暴露出来，也就是说不管更新在setter或者mutator中触发了，我们并不能再外部去调用方法去更新。 同时虽然取值的时候可以会触发getter，而在setter或者mutator中赋值的时候可以通知改变，但是有个问题是我们并不知道getter中是哪个方法或者对象调用的，因此我们就不知道去通知谁去更新。 为了解决这两个问题，我们需要定义一个依赖对象，这个对象有一个取值get方法，和一个update更新方法。当调用取值方法时可以触发getter，在取值前我们将这个对象挂载到一个全局的对象中，这样在触发getter方法时我们就可以通过全局对象获取到我们的依赖对象并将其收集起来，当触发setter或者mutator的时候我们就调用依赖对象的update方法实现更新操作。","text":"如何利用变化侦测我们在前面已经做到了将一个对象上所有属性进行侦测，也就是说任何值改变我们都能知道。但是并没有将对应的方法暴露出来，也就是说不管更新在setter或者mutator中触发了，我们并不能再外部去调用方法去更新。 同时虽然取值的时候可以会触发getter，而在setter或者mutator中赋值的时候可以通知改变，但是有个问题是我们并不知道getter中是哪个方法或者对象调用的，因此我们就不知道去通知谁去更新。 为了解决这两个问题，我们需要定义一个依赖对象，这个对象有一个取值get方法，和一个update更新方法。当调用取值方法时可以触发getter，在取值前我们将这个对象挂载到一个全局的对象中，这样在触发getter方法时我们就可以通过全局对象获取到我们的依赖对象并将其收集起来，当触发setter或者mutator的时候我们就调用依赖对象的update方法实现更新操作。 WatcherWatcher就是这样的一个依赖对象，它就像一个中介的角色，连接了最终的数据和回调函数。它的数据可以是一段路径表达式也可以是一个函数（expOrFn），我们将其定义成getter方法。 同时我们定义了一个get方法，在取值前先将Watcher对象挂载到全局对象上，调用它让依赖能被收集起来。 12345678910111213141516171819202122232425262728293031323334function Watcher (vm, expOrFn, cb, options) &#123; if (options) &#123; extend(this, options) &#125; this.vm = vm this.expression = expOrFn this.cb = cb if (typeof expOrFn === 'function') &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) &#125; this.value = this.get() this.shallow = false&#125;Watcher.prototype.get = function () &#123; window.target = this var value = this.getter.call(this.vm, this.vm) window.target = null return value&#125;Watcher.prototype.update = function () &#123; var value = this.get() if ( value !== this.value || ((isObject(value) || this.deep) &amp;&amp; !this.shallow) ) &#123; var oldValue = this.value this.value = value this.cb.call(this.vm, value, oldValue) &#125;&#125; 工具方法1234567891011121314151617181920212223function parsePath(path) &#123; const segments = path.split('.') //闭包保存层级数组 return function(obj) &#123; for (let i = 0; i &lt; segments.length; i++) &#123; if (!obj) return; obj = obj[segments[i]]; &#125; return obj; &#125;&#125;function isObject (obj) &#123; return obj !== null &amp;&amp; typeof obj === 'object'&#125;function extend (to, from) &#123; var keys = Object.keys(from) var i = keys.length while (i--) &#123; to[keys[i]] = from[keys[i]] &#125; return to&#125; parsePath： 使我们可以对更复杂的层级属性进行监听时（比如我们想侦测到data.a.b.c的时候）。 isObject： 检测一个值是否为对象。 extend： 可以将一个对象的属性拷贝到另一个对象上。 Demo查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Watcher","slug":"Watcher","permalink":"https://eagune.github.io/tags/Watcher/"},{"name":"依赖","slug":"依赖","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96/"}]},{"title":"（二）Observer将数据对象变成响应式","slug":"vue深入理解/Observer将数据对象变成响应式","date":"2020-04-25T09:43:39.000Z","updated":"2020-05-22T04:17:23.398Z","comments":true,"path":"vue深入理解/Observer将数据对象变成响应式/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Observer%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%88%90%E5%93%8D%E5%BA%94%E5%BC%8F/","excerpt":"通过前面的方法我们已经可以实现变化侦测的功能了，但是只做到了对数据对象中的某一个属性进行侦测，而我们希望对这个数据对象中的所有属性进行侦测，因此我们需要封装一个Observer类。 Observer12345678910111213141516171819202122232425262728293031var arrayKeys = Object.getOwnPropertyNames(arrayMethods)function Observer (value) &#123; this.value = value def(value, '__ob__', this) if (Array.isArray(value)) &#123; var augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) &#125; else &#123; this.walk(value) &#125;&#125;function observe (value) &#123; if (!value || typeof value !== 'object') &#123; return &#125; var ob if ( Object.prototype.hasOwnProperty.call(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer ) &#123; ob = value.__ob__ &#125; else if ( (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) ) &#123; ob = new Observer(value) &#125; return ob&#125; 首先我们在构造Observer的时候会给我们要观测对象添加一个__ob__属性，这个属性指向这个Observer。通过检查对象上的这个属性我们可以知道这个对象是否已经被观测过，从而避免重复的观测。","text":"通过前面的方法我们已经可以实现变化侦测的功能了，但是只做到了对数据对象中的某一个属性进行侦测，而我们希望对这个数据对象中的所有属性进行侦测，因此我们需要封装一个Observer类。 Observer12345678910111213141516171819202122232425262728293031var arrayKeys = Object.getOwnPropertyNames(arrayMethods)function Observer (value) &#123; this.value = value def(value, '__ob__', this) if (Array.isArray(value)) &#123; var augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) &#125; else &#123; this.walk(value) &#125;&#125;function observe (value) &#123; if (!value || typeof value !== 'object') &#123; return &#125; var ob if ( Object.prototype.hasOwnProperty.call(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer ) &#123; ob = value.__ob__ &#125; else if ( (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) ) &#123; ob = new Observer(value) &#125; return ob&#125; 首先我们在构造Observer的时候会给我们要观测对象添加一个__ob__属性，这个属性指向这个Observer。通过检查对象上的这个属性我们可以知道这个对象是否已经被观测过，从而避免重复的观测。 123456789101112131415161718192021222324252627282930Observer.prototype.observeArray = function (items) &#123; for (var i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125;&#125;Observer.prototype.walk = function (obj) &#123; var keys = Object.keys(obj) for (var i = 0, l = keys.length; i &lt; l; i++) &#123; defineReactive(this.value, keys[i], obj[keys[i]]) &#125;&#125;function defineReactive(data, key, value) &#123; var childOb = observe(value) Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; return value; &#125;, set: function(newVal) &#123; if (value === newVal) &#123; return; &#125; value = newVal; childOb = observe(newVal) &#125; &#125;);&#125; 然后我们判断这个值是数组还是对象。如果是数组那么给它应用上拦截器，并用observe方法遍历数组中的每一个值。如果是对象，我们就遍历这个对象上的每一个属性，将其转换为响应式的对象属性。 不管是数组还是对象属性在遍历的时候我们都对它的值进行了观测observe，如果这个值也是一个数组或对象，我们就继续构造一个Observer对象，通过这种递归调用的形式，我们就可以将对象上的所有属性包括子属性、数组中的值都侦测到。 工具方法12345678910111213141516171819202122232425function def (obj, key, val, enumerable) &#123; Object.defineProperty(obj, key, &#123; value: val, enumerable: !!enumerable, writable: true, configurable: true &#125;)&#125;function isPlainObject (obj) &#123; return Object.prototype.toString.call(obj) === '[object Object]'&#125;var hasProto = '__proto__' in &#123;&#125;function protoAugment (target, src) &#123; target.__proto__ = src&#125;function copyAugment (target, src, keys) &#123; for (var i = 0, l = keys.length; i &lt; l; i++) &#123; var key = keys[i] def(target, key, src[key]) &#125;&#125; def方法可以给对象添加一个属性，默认是不可枚举的。 isPlainObject则是用来严格检验一个对象是否是一个简单的JavaScript对象。 hasProto判断浏览器是否支持__proto__。 protoAugment设置目标的__proto__。 copyAugment将目标对象添加对应的属性。 Demo查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Observer","slug":"Observer","permalink":"https://eagune.github.io/tags/Observer/"},{"name":"响应式","slug":"响应式","permalink":"https://eagune.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"}]},{"title":"（一）Vue中变化侦测的原理","slug":"vue深入理解/Vue中变化侦测的原理","date":"2020-04-24T19:16:26.000Z","updated":"2020-05-22T04:17:23.398Z","comments":true,"path":"vue深入理解/Vue中变化侦测的原理/","link":"","permalink":"https://eagune.github.io/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Vue%E4%B8%AD%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"变化侦测变化侦测是实现响应式的核心。它的作用是当数据变化时，通知视图进行相应的更新。 我们的应用程序在运行时内部的状态会不断发生变化，而变化侦测就是检测到系统哪一个部分发生了变化。 比如在Angular中的脏检测，React中的虚拟DOM，而Vue中实现变化侦测的方式是对数据的劫持（元编程）。 这种方式的好处是在状态发生变化时，我们的程序就立马知道了，然后我们就可以对绑定了这个状态的所有依赖发送通知，让它们进行更新。 在javascript中使用Object.defineProperty可以侦测到一个对象的变化，然而它并不能侦测到数组中的变化，因此我们需要分别讨论。","text":"变化侦测变化侦测是实现响应式的核心。它的作用是当数据变化时，通知视图进行相应的更新。 我们的应用程序在运行时内部的状态会不断发生变化，而变化侦测就是检测到系统哪一个部分发生了变化。 比如在Angular中的脏检测，React中的虚拟DOM，而Vue中实现变化侦测的方式是对数据的劫持（元编程）。 这种方式的好处是在状态发生变化时，我们的程序就立马知道了，然后我们就可以对绑定了这个状态的所有依赖发送通知，让它们进行更新。 在javascript中使用Object.defineProperty可以侦测到一个对象的变化，然而它并不能侦测到数组中的变化，因此我们需要分别讨论。 Object的变化侦测我们定义一个defineReactive函数对Object.defineProperty进行封装，方便我们实现将对象中的某个数据转换成响应式的数据，每次从读取数据时会触发get函数，而每次设置数据时会触发set函数。 12345678910111213function defineReactive(obj, property, value) &#123; Object.defineProperty(obj, property, &#123; enumerable: true, configurable: true, get: function() &#123; return value; &#125;, set: function(newValue) &#123; if (newValue === value) return value = newValue; &#125;, &#125;)&#125; 查看DEMO Array的变化侦测在对Object进行变化侦测的时候是使用getter/setter的方式来进行追踪，然而对于数组类型，虽然读取数据时依然会触发get函数，但是并不能检测到我们通过push、pop等方法操作数组带来的改变。 因此我们采用另外一种方式实现变化侦测：拦截器。就是当我们调用数组的push、pop等方法的时候，先进入我们自定义的方法这样我们就可以知道这个变化，这时候我们在对依赖进行通知，然后调用数组的原始方法。 123456789101112131415161718192021const arrayProto = Array.prototype;const arrayMethods = Object.create(arrayProto);[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function(method) &#123; const original = arrayProto[method]; Object.defineProperty(arrayMethods, method, &#123; value: function mutator(...args) &#123;//使用rest参数可以避免将argumesnts对象转换为数组 return original.apply(this, args) &#125;, enumerable: false, //不让方法出现在枚举属性中 writable: true, configurable: true, &#125;)&#125;) 首先我们创建了arrayMethods对象来保存数组的原始方法，并对（push、pop、shift、unshift、splice、sort、reverse）这7种方法进行劫持。原理依然是我们调用这些方法的时候其实也是调用了原型对象上的一个属性，所以它依然可以触发这个属性的一个getter。 在使用的时候我们只希望我们对我们需要侦测数组进行劫持，所以我们不能覆盖Array.prototype，因此我们可以通过改变数据的__proto__指向我们的原型方法来实现。 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"变化侦测","slug":"变化侦测","permalink":"https://eagune.github.io/tags/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"},{"name":"defineReactive","slug":"defineReactive","permalink":"https://eagune.github.io/tags/defineReactive/"},{"name":"Object.defineProperty","slug":"Object-defineProperty","permalink":"https://eagune.github.io/tags/Object-defineProperty/"}]}],"categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"},{"name":"网络协议","slug":"网络协议","permalink":"https://eagune.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"终端指令","slug":"终端指令","permalink":"https://eagune.github.io/tags/%E7%BB%88%E7%AB%AF%E6%8C%87%E4%BB%A4/"},{"name":"网络协议","slug":"网络协议","permalink":"https://eagune.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://eagune.github.io/tags/HTTP%E5%8D%8F%E8%AE%AE/"},{"name":"请求行","slug":"请求行","permalink":"https://eagune.github.io/tags/%E8%AF%B7%E6%B1%82%E8%A1%8C/"},{"name":"URI","slug":"URI","permalink":"https://eagune.github.io/tags/URI/"},{"name":"OSI模型","slug":"OSI模型","permalink":"https://eagune.github.io/tags/OSI%E6%A8%A1%E5%9E%8B/"},{"name":"TCP/IP模型","slug":"TCP-IP模型","permalink":"https://eagune.github.io/tags/TCP-IP%E6%A8%A1%E5%9E%8B/"},{"name":"指令","slug":"指令","permalink":"https://eagune.github.io/tags/%E6%8C%87%E4%BB%A4/"},{"name":"解析","slug":"解析","permalink":"https://eagune.github.io/tags/%E8%A7%A3%E6%9E%90/"},{"name":"Directives","slug":"Directives","permalink":"https://eagune.github.io/tags/Directives/"},{"name":"行为预设","slug":"行为预设","permalink":"https://eagune.github.io/tags/%E8%A1%8C%E4%B8%BA%E9%A2%84%E8%AE%BE/"},{"name":"表达式","slug":"表达式","permalink":"https://eagune.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"模板","slug":"模板","permalink":"https://eagune.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"转换","slug":"转换","permalink":"https://eagune.github.io/tags/%E8%BD%AC%E6%8D%A2/"},{"name":"Fragment","slug":"Fragment","permalink":"https://eagune.github.io/tags/Fragment/"},{"name":"Dep","slug":"Dep","permalink":"https://eagune.github.io/tags/Dep/"},{"name":"依赖收集","slug":"依赖收集","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/"},{"name":"Watcher","slug":"Watcher","permalink":"https://eagune.github.io/tags/Watcher/"},{"name":"依赖","slug":"依赖","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96/"},{"name":"Observer","slug":"Observer","permalink":"https://eagune.github.io/tags/Observer/"},{"name":"响应式","slug":"响应式","permalink":"https://eagune.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"变化侦测","slug":"变化侦测","permalink":"https://eagune.github.io/tags/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"},{"name":"defineReactive","slug":"defineReactive","permalink":"https://eagune.github.io/tags/defineReactive/"},{"name":"Object.defineProperty","slug":"Object-defineProperty","permalink":"https://eagune.github.io/tags/Object-defineProperty/"}]}