{"meta":{"title":"Eagune's Blog","subtitle":"","description":"","author":"Eagune","url":"https://eagune.github.io","root":"/"},"pages":[],"posts":[{"title":"（六）表达式解析","slug":"vue深入理解/表达式解析","date":"2020-05-09T22:33:25.000Z","updated":"2020-05-12T00:57:07.819Z","comments":true,"path":"2020/05/09/vue深入理解/表达式解析/","link":"","permalink":"https://eagune.github.io/2020/05/09/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/","excerpt":"表达式解析","text":"表达式解析 parseText12345678910111213141516171819202122232425262728293031323334353637383940function parseText (text) &#123; var tagRE = /\\&#123;\\&#123;((?:.|\\n)+?)\\&#125;\\&#125;/g // (?:.|\\n)中，.匹配换行符以外的字符 // 因为有的系统的换行符是\\r\\n // 所以.|\\n匹配除了\\r之外的任意字符 // ?:表示非捕获型括号，所以整个的就是匹配任意一个非\\r的字符 if (!tagRE.test(text)) &#123; return null &#125; var tokens = [] var lastIndex = tagRE.lastIndex = 0 // 在正则中lastIndex属性用于规定下次匹配的起始位置 // 因此我们每次匹配到后需要设置lastIndex为0下次才会匹配到正确的结果 var match, index, html, value while (match = tagRE.exec(text)) &#123; index = match.index // push text token if (index &gt; lastIndex) &#123; tokens.push(&#123; value: text.slice(lastIndex, index) &#125;) &#125; // tag token value = match[1] tokens.push(&#123; tag: true, value: value.trim(), &#125;) lastIndex = index + match[0].length &#125; if (lastIndex &lt; text.length) &#123; tokens.push(&#123; value: text.slice(lastIndex) &#125;) &#125; return tokens&#125;// 较源码省略了的地方：缓存、三重大括号显示html。 compile12345678910111213141516171819202122232425262728293031323334353637383940414243444546function compile(el)&#123; if (el.hasChildNodes()) &#123; compileNodeList(el.childNodes) &#125;&#125;function compileNodeList(nodeList)&#123; var node for (var i = 0, l = nodeList.length; i &lt; l; i++) &#123; node = nodeList[i] compileNode(node) if (node.hasChildNodes()) &#123; compileNodeList(node.childNodes) &#125; &#125;&#125;function compileNode (node) &#123; var type = node.nodeType if (type === 3 &amp;&amp; node.data.trim()) &#123; compileTextNode(node) &#125;&#125;function compileTextNode (node) &#123; var tokens = parseText(node.wholeText) if (!tokens) &#123; return null &#125; var frag = document.createDocumentFragment() var el, token for (var i = 0, l = tokens.length; i &lt; l; i++) &#123; token = tokens[i] if (token.tag) &#123; el = document.createTextNode(' ') new Watcher(data, token.value, function(value, oldValue) &#123; var attr = el.nodeType === 3 ? 'data' : 'textContent'; el[attr] = value == null ? '' : value.toString() &#125;); &#125; else &#123; el = document.createTextNode(token.value) &#125; frag.appendChild(el) &#125; replace(node, frag)&#125; 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"表达式解析","slug":"表达式解析","permalink":"https://eagune.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/"}]},{"title":"（五）模板字符串转换成DOM","slug":"vue深入理解/模板字符串转换成DOM","date":"2020-05-09T17:55:06.000Z","updated":"2020-05-12T00:57:07.819Z","comments":true,"path":"2020/05/09/vue深入理解/模板字符串转换成DOM/","link":"","permalink":"https://eagune.github.io/2020/05/09/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90DOM/","excerpt":"模板在前面的章节中我们已经知道了通过对数据进行劫持的方式可以让我们以这种通过数据驱动的方式去开发一个应用程序。但是如果全部在Watcher中做控制这样需要写很多重复性的控制视图的代码。 这样显然是很麻烦的，MVVM的核心是在MVC的基础上将view的状态行为抽象化。 在Vue中模板就是用来声明我们应用程序的数据与界面的绑定关系。 在Vue中模板不仅可以做到绑定数据还可以做到诸如循环判断等复杂功能，因此一定是一个图灵完备的语言去实现而不是html，它只是一种接近html的写法。 在Javascript中模板本质上也就是字符串，因此在Vue的运行过程中还需要将我们的模板字符串转换成DOM节点，并在这个过程中实现与我们数据的绑定。","text":"模板在前面的章节中我们已经知道了通过对数据进行劫持的方式可以让我们以这种通过数据驱动的方式去开发一个应用程序。但是如果全部在Watcher中做控制这样需要写很多重复性的控制视图的代码。 这样显然是很麻烦的，MVVM的核心是在MVC的基础上将view的状态行为抽象化。 在Vue中模板就是用来声明我们应用程序的数据与界面的绑定关系。 在Vue中模板不仅可以做到绑定数据还可以做到诸如循环判断等复杂功能，因此一定是一个图灵完备的语言去实现而不是html，它只是一种接近html的写法。 在Javascript中模板本质上也就是字符串，因此在Vue的运行过程中还需要将我们的模板字符串转换成DOM节点，并在这个过程中实现与我们数据的绑定。 stringToFragment为什么要将字符串转换为Fragment呢？因为频繁调用DOM的API会非常耗性能，而我们使用虚拟的节点对象会减少页面渲染dom的次数，效率会明显提升。 同时使用innerHTML让浏览器自行解析可以很方便的帮我们将字符串转换成合法的DOM节点，为我们后续的操作提供便利。 123456789101112131415161718192021222324const tagRE = /&lt;([\\w:-]+)/const entityRE = /&amp;#?\\w+?;/const commentRE = /&lt;!--/function stringToFragment (templateString) &#123; var frag = document.createDocumentFragment() var tagMatch = templateString.match(tagRE) var entityMatch = entityRE.test(templateString) var commentMatch = commentRE.test(templateString) if (!tagMatch &amp;&amp; !entityMatch &amp;&amp; !commentMatch) &#123; // text only, return a single text node. frag.appendChild( document.createTextNode(templateString) ) &#125; else &#123; var node = document.createElement('div') node.innerHTML = templateString frag.appendChild(node) &#125; return frag&#125;// 较源码省略了的地方：诸如td、option等需要嵌套的标签如果直接使用生成的fragment并不会生效，我们需要手动的拼接加上外层。 transclude我们将根节点的各种属性复制到根据模板生成的节点上，并替换掉html上的根节点。 1234567891011121314151617181920212223242526272829function init (el, template) &#123; var origin = el el = transcludeTemplate(el, template) replace(origin, el) return el&#125;function replace (target, el) &#123; var parent = target.parentNode if (parent) &#123; parent.replaceChild(el, target) &#125;&#125;function transcludeTemplate (el, template) &#123; var frag = stringToFragment(template) var replacer = frag.firstChild var attrs = el.attributes var i = attrs.length var name, value while (i--) &#123; name = attrs[i].name value = attrs[i].value if (!replacer.hasAttribute(name)) &#123; replacer.setAttribute(name, value) &#125; &#125; return replacer&#125; 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"模板","slug":"模板","permalink":"https://eagune.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"转换","slug":"转换","permalink":"https://eagune.github.io/tags/%E8%BD%AC%E6%8D%A2/"},{"name":"Fragment","slug":"Fragment","permalink":"https://eagune.github.io/tags/Fragment/"}]},{"title":"（三）Watcher依赖数据的对象","slug":"vue深入理解/Watcher依赖数据的对象","date":"2020-04-26T09:58:52.000Z","updated":"2020-05-12T00:57:07.819Z","comments":true,"path":"2020/04/26/vue深入理解/Watcher依赖数据的对象/","link":"","permalink":"https://eagune.github.io/2020/04/26/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Watcher%E4%BE%9D%E8%B5%96%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E8%B1%A1/","excerpt":"Watcher当我们侦测到数据变化的时候，需要对不同的情况进行不同的处理，显然我们不能都放在setter中，因此我们需要抽象出一个能集中处理这种情况的类。","text":"Watcher当我们侦测到数据变化的时候，需要对不同的情况进行不同的处理，显然我们不能都放在setter中，因此我们需要抽象出一个能集中处理这种情况的类。 12345678910111213141516171819class Watcher &#123; constructor(vm, key, cb) &#123; this.vm = vm; this.key = key; this.cb = cb; window.target = this; this.value = this.vm[this.key]; window.target = undefined; this.cb.call(this.vm, this.value); &#125; update() &#123; const oldValue = this.value; this.value = this.vm[this.key]; this.cb.call(this.vm, this.value, oldValue); &#125;&#125; 由于我们在getter中无法获取到调用它的对象，因此我们通过将Watcher挂载到全局对象的方法，在建立依赖关系的时候我们先将Watcher挂载到全局对象上，然后取值触发getter方法，这样在getter方法中就能将依赖的对象收集起来。 12345678910111213141516171819202122function defineReactive(data, key, value) &#123; let deps = []; Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; if(window.target) &#123; deps.push(window.target); &#125; return value; &#125;, set: function(newVal) &#123; if (value === newVal) &#123; return; &#125; value = newVal; for (let i = 0; i &lt; deps.length; i++) &#123; deps[i].update(); &#125; &#125; &#125;);&#125; 查看DEMO 对于数组类型的触发我们对数组的侦测是通过拦截器进行的，因此他们发出通知的位置也是在拦截器中进行。 由于需要在拦截器中访问到Watcher，因此我们要将依赖对象放到Observer中。我们改造一下Observer，当处理数组的时候，我们给数组添加一个__ob__属性指向我们这个Observer。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Observer &#123; constructor(value) &#123; this.value = value; if (!Array.isArray(value)) &#123; this.walk(value); &#125; else &#123; this.deps = []; let instance = this; Object.defineProperty(value, '__ob__', &#123; value: instance, enumerable: false, writable: true, configurable: true, &#125;); value.__proto__ = arrayMethods; &#125; &#125; walk(object) &#123; ... &#125;&#125;const arrayProto = Array.prototype;const arrayMethods = Object.create(arrayProto);[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function(method) &#123; const original = arrayProto[method]; Object.defineProperty(arrayMethods, method, &#123; value: function mutator(...args) &#123; const result = original.apply(this, args); let deps = this.__ob__.deps; for (let i = 0; i &lt; deps.length; i++) &#123; deps[i].update(); &#125; return result; &#125;, enumerable: false, writable: true, configurable: true, &#125;)&#125;) 虽然我们触发Watcher是在拦截器中，但是我们收集依赖还是在getter中的，而我们保存在observer中，因此我们还需要对收集依赖的地方进行改造。 1234567891011121314151617181920212223242526272829303132function defineReactive(data, key, value) &#123; let instance; if (typeof value === 'object') &#123; instance = new Observer(value); &#125; let deps = []; Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; if(window.target) &#123; deps.push(window.target); if(instance &amp;&amp; instance.deps) &#123; instance.deps.push(window.target); &#125; &#125; return value; &#125;, set: function(newVal) &#123; if (value === newVal) &#123; return; &#125; value = newVal; for (let i = 0; i &lt; deps.length; i++) &#123; deps[i].update(); &#125; if (typeof value === 'object') &#123; new Observer(value); &#125; &#125; &#125;);&#125; 查看DEMO parsePath让Watcher支持复杂的层级当对于更复杂的层级属性进行监听时（比如我们想侦测到data.a.b.c的时候），上面的方法显然是不够用的。因此我们需要对上面的方法进行升级。 123456789101112131415161718192021222324252627282930function parsePath(path) &#123; const segments = path.split('.') //闭包保存层级数组 return function(obj) &#123; for (let i = 0; i &lt; segments.length; i++) &#123; if (!obj) return; obj = obj[segments[i]]; &#125; return obj; &#125;&#125;class Watcher &#123; constructor(vm, expression, cb) &#123; this.vm = vm; this.getter = parsePath(expression); this.cb = cb; window.target = this; this.value = this.getter.call(this.vm); window.target = undefined; this.cb.call(this.vm, this.value); &#125; update() &#123; const oldValue = this.value; this.value = this.vm[this.key]; this.cb.call(this.vm, this.value, oldValue); &#125;&#125; 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Watcher","slug":"Watcher","permalink":"https://eagune.github.io/tags/Watcher/"},{"name":"依赖","slug":"依赖","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96/"}]},{"title":"（四）Dep依赖收集","slug":"vue深入理解/Dep依赖收集","date":"2020-04-25T13:33:50.000Z","updated":"2020-05-12T00:57:07.819Z","comments":true,"path":"2020/04/25/vue深入理解/Dep依赖收集/","link":"","permalink":"https://eagune.github.io/2020/04/25/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Dep%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/","excerpt":"封装Dep我们可以将defineReactive中收集依赖，通知依赖的命令式代码封装一下。","text":"封装Dep我们可以将defineReactive中收集依赖，通知依赖的命令式代码封装一下。 1234567891011121314151617class Dep &#123; constructor(value) &#123; this.subs = []; &#125; depend() &#123; if (window.target) &#123; this.subs.push(window.target); &#125; &#125; notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update(); &#125;) &#125;&#125; 在defineReactive中使用Dep123456789101112131415161718192021222324function defineReactive(data, key, value) &#123; if (typeof value === 'object') &#123; new Observer(value); &#125; let dep = new Dep(); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; dep.depend(); //新增 return value; &#125;, set: function(newVal) &#123; if (value === newVal) &#123; return; &#125; value = newVal; if (typeof value === 'object') &#123; new Observer(value); &#125; dep.notify(); //通知 &#125; &#125;);&#125; 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Dep","slug":"Dep","permalink":"https://eagune.github.io/tags/Dep/"},{"name":"依赖收集","slug":"依赖收集","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/"}]},{"title":"（二）Observer将数据对象变成响应式","slug":"vue深入理解/Observer将数据对象变成响应式","date":"2020-04-25T09:43:39.000Z","updated":"2020-05-12T00:57:07.819Z","comments":true,"path":"2020/04/25/vue深入理解/Observer将数据对象变成响应式/","link":"","permalink":"https://eagune.github.io/2020/04/25/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Observer%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%88%90%E5%93%8D%E5%BA%94%E5%BC%8F/","excerpt":"Observer我们已经知道了变化侦测的原理了，并且知道了Object和Array的不同，现在我们封装一个Observer类，将一个数据对象中的所有属性都进行追踪。","text":"Observer我们已经知道了变化侦测的原理了，并且知道了Object和Array的不同，现在我们封装一个Observer类，将一个数据对象中的所有属性都进行追踪。 123456789101112131415161718192021222324252627282930313233343536373839class Observer &#123; constructor(value) &#123; this.value = value; if (!Array.isArray(value)) &#123; this.walk(value); &#125; else &#123; value.__proto__ = arrayMethods; &#125; &#125; walk(object) &#123; for (let key in object) &#123; defineReactive(object, key, object[key]); &#125; &#125;&#125;function defineReactive(data, key, value) &#123; if (typeof value === 'object') &#123; new Observer(value); &#125; Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; return value; &#125;, set: function(newVal) &#123; if (value === newVal) &#123; return; &#125; value = newVal; if (typeof value === 'object') &#123; new Observer(value); &#125; &#125; &#125;);&#125; 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"Observer","slug":"Observer","permalink":"https://eagune.github.io/tags/Observer/"},{"name":"响应式","slug":"响应式","permalink":"https://eagune.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"}]},{"title":"（一）Vue中变化侦测的原理","slug":"vue深入理解/Vue中变化侦测的原理","date":"2020-04-24T19:16:26.000Z","updated":"2020-05-12T00:57:07.819Z","comments":true,"path":"2020/04/24/vue深入理解/Vue中变化侦测的原理/","link":"","permalink":"https://eagune.github.io/2020/04/24/vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/Vue%E4%B8%AD%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"变化侦测是Vue中实现响应式的核心。它的作用是当数据变化时，通知视图进行相应的更新。","text":"变化侦测是Vue中实现响应式的核心。它的作用是当数据变化时，通知视图进行相应的更新。 Object的变化侦测在javascript中有两种方法可以侦测到一个对象的变化：Object.defineProperty和ES6的Proxy。 12345678910111213function defineReactive(obj, property, value) &#123; Object.defineProperty(obj, property, &#123; enumerable: true, configurable: true, get: function() &#123; return value; &#125;, set: function(newValue) &#123; if (newValue === value) return value = newValue; &#125;, &#125;)&#125; 查看DEMO Array的变化侦测在对Object进行变化侦测的时候是使用getter/setter的方式来进行追踪。而用push等方法来改变数组中的内容时并不会出发setter。因此我们采用拦截器的方式覆盖Array.prototype来对数组进行追踪。 123456789101112131415161718192021const arrayProto = Array.prototype;const arrayMethods = Object.create(arrayProto);[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function(method) &#123; const original = arrayProto[method]; Object.defineProperty(arrayMethods, method, &#123; value: function mutator(...args) &#123;//使用rest参数可以避免将argumesnts对象转换为数组 return original.apply(this, args) &#125;, enumerable: false, //不让方法出现在枚举属性中 writable: true, configurable: true, &#125;)&#125;) 查看DEMO","categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"变化侦测","slug":"变化侦测","permalink":"https://eagune.github.io/tags/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"},{"name":"defineReactive","slug":"defineReactive","permalink":"https://eagune.github.io/tags/defineReactive/"},{"name":"Object.defineProperty","slug":"Object-defineProperty","permalink":"https://eagune.github.io/tags/Object-defineProperty/"}]}],"categories":[{"name":"Vue深入理解","slug":"Vue深入理解","permalink":"https://eagune.github.io/categories/Vue%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://eagune.github.io/tags/vue/"},{"name":"表达式解析","slug":"表达式解析","permalink":"https://eagune.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/"},{"name":"模板","slug":"模板","permalink":"https://eagune.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"转换","slug":"转换","permalink":"https://eagune.github.io/tags/%E8%BD%AC%E6%8D%A2/"},{"name":"Fragment","slug":"Fragment","permalink":"https://eagune.github.io/tags/Fragment/"},{"name":"Watcher","slug":"Watcher","permalink":"https://eagune.github.io/tags/Watcher/"},{"name":"依赖","slug":"依赖","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96/"},{"name":"Dep","slug":"Dep","permalink":"https://eagune.github.io/tags/Dep/"},{"name":"依赖收集","slug":"依赖收集","permalink":"https://eagune.github.io/tags/%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/"},{"name":"Observer","slug":"Observer","permalink":"https://eagune.github.io/tags/Observer/"},{"name":"响应式","slug":"响应式","permalink":"https://eagune.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"变化侦测","slug":"变化侦测","permalink":"https://eagune.github.io/tags/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"},{"name":"defineReactive","slug":"defineReactive","permalink":"https://eagune.github.io/tags/defineReactive/"},{"name":"Object.defineProperty","slug":"Object-defineProperty","permalink":"https://eagune.github.io/tags/Object-defineProperty/"}]}