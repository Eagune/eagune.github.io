<!DOCTYPE html><html><head><meta http-equiv="Content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title></title><link href="/demo/vendor.css" rel="stylesheet"><link href="/demo/client.css" rel="stylesheet"></head><body><div id="app"></div><script>window.HtmlCode='',window.HtmlFold=[],window.CssCode="",window.CssFold=[],window.JsCode="function def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  })\n}\nfunction isPlainObject (obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]'\n}\nvar hasProto = '__proto__' in {}\nfunction protoAugment (target, src) {\n  target.__proto__ = src\n}\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i]\n    def(target, key, src[key])\n  }\n}\nfunction parsePath(path) {\n  const segments = path.split('.') //闭包保存层级数组\n  return function(obj) {\n    for (let i = 0; i < segments.length; i++) {\n      if (!obj) return;\n      obj = obj[segments[i]];\n    }\n    return obj;\n  }\n}\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\nfunction extend (to, from) {\n  var keys = Object.keys(from)\n  var i = keys.length\n  while (i--) {\n    to[keys[i]] = from[keys[i]]\n  }\n  return to\n}\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n].forEach(\n  function(method) {\n    const original = arrayProto[method];\n    def(arrayMethods, method, function mutator () {\n      var i = arguments.length\n      var args = new Array(i)\n      while (i--) {\n        args[i] = arguments[i]\n      }\n      var result = original.apply(this, args)\n      var ob = this.__ob__\n      var inserted\n      switch (method) {\n        case 'push':\n          inserted = args\n          break\n        case 'unshift':\n          inserted = args\n          break\n        case 'splice':\n          inserted = args.slice(2)\n          break\n      }\n      if (inserted) ob.observeArray(inserted)\n      ob.dep.notify()\n      return result\n    })\n  }\n)\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods)\nfunction Observer (value) {\n  this.value = value\n  def(value, '__ob__', this)\n  if (Array.isArray(value)) {\n    var augment = hasProto ? protoAugment : copyAugment\n    augment(value, arrayMethods, arrayKeys)\n    this.observeArray(value)\n  } else {\n    this.walk(value)\n  }\n}\nObserver.prototype.observeArray = function (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i])\n  }\n}\nObserver.prototype.walk = function (obj) {\n  var keys = Object.keys(obj)\n  for (var i = 0, l = keys.length; i < l; i++) {\n    defineReactive(this.value, keys[i], obj[keys[i]])\n  }\n}\nfunction observe (value) {\n  if (!value || typeof value !== 'object') {\n    return\n  }\n  var ob\n  if (\n    Object.prototype.hasOwnProperty.call(value, '__ob__') &&\n    value.__ob__ instanceof Observer\n  ) {\n    ob = value.__ob__\n  } else if (\n    (Array.isArray(value) || isPlainObject(value))\n    && Object.isExtensible(value)\n  ) {\n    ob = new Observer(value)\n  }\n  return ob\n}\n\nfunction Watcher (vm, expOrFn, cb, options) {\n  if (options) {\n    extend(this, options)\n  }\n  this.vm = vm\n  this.expression = expOrFn\n  this.cb = cb\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn\n  } else {\n    this.getter = parsePath(expOrFn)\n  }\n  this.value = this.get()\n  this.shallow = false\n}\nWatcher.prototype.get = function () {\n  Dep.target = this\n  var value = this.getter.call(this.vm, this.vm)\n  Dep.target = null\n  return value\n}\nWatcher.prototype.update = function () {\n  var value = this.get()\n  if (\n    value !== this.value ||\n    ((isObject(value) || this.deep) && !this.shallow)\n  ) {\n    var oldValue = this.value\n    this.value = value\n    this.cb.call(this.vm, value, oldValue)\n  }\n}\n\nfunction Dep () {\n  this.subs = []\n}\nDep.target = null\nDep.prototype.depend = function () {\n  if (Dep.target) {\n    if (this.subs.indexOf(Dep.target) <= -1) {\n      this.subs.push(Dep.target)\n    }\n  }\n}\nDep.prototype.notify = function () {\n  var subs = this.subs\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update()\n  }\n}\n\nfunction defineReactive(data, key, value) {\n  var dep = new Dep()\n  var childOb = observe(value)\n  Object.defineProperty(data, key, {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n        }\n        if (Array.isArray(value)) {\n          for (var e, i = 0, l = value.length; i < l; i++) {\n            e = value[i]\n            e && e.__ob__ && e.__ob__.dep.depend()\n          }\n        }\n      }\n      return value;\n    },\n    set: function(newVal) {\n      if (value === newVal) {\n        return;\n      }\n      value = newVal;\n      childOb = observe(newVal)\n      dep.notify()\n    }\n  });\n}\n\nvar data = {\n  name: 'Jhon'\n}\nnew Observer(data);\n\nvar watcher1 = new Watcher(data, 'name', function(newName){\n  console.log(newName)\n})\nvar watcher2 = new Watcher(data, 'name', function(newName){\n  console.log(newName)\n})\ndata.name = 'Bob'",window.JsFold=[0,8,12,15,21,31,34,45,54,84,95,100,106,125,140,146,158,162,169,176]</script><script type="text/javascript" src="/demo/manifest.js"></script><script type="text/javascript" src="/demo/vendor.js"></script><script type="text/javascript" src="/demo/client.js"></script></body></html>